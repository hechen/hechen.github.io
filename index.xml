<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>I make stuff</title>
    <link>https://hechen.xyz/</link>
    <description>Recent content on I make stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 20 Aug 2017 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://hechen.xyz/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://hechen.xyz/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://hechen.xyz/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于一次 SS 流量丢失的过程记录</title>
      <link>https://hechen.xyz/post/%E5%85%B3%E4%BA%8E%E4%B8%80%E6%AC%A1-ss-%E6%B5%81%E9%87%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 28 Jan 2019 17:51:35 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/%E5%85%B3%E4%BA%8E%E4%B8%80%E6%AC%A1-ss-%E6%B5%81%E9%87%8F%E4%B8%A2%E5%A4%B1%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</guid>
      
        <description>

&lt;h3 id=&#34;2019-01-29-更新&#34;&gt;2019-01-29 更新&lt;/h3&gt;

&lt;p&gt;早上一到办公室连接上公司网络，网速直接就飚到了 600KB/s，甚至一度有过 M 的趋势，果不其然，还是 com.apple.Safari.SafeBrowsing.Service 这个服务进程。这就尴尬了，看来并不是说你不用 Safari 就不会触发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yifgIEZ.png&#34; alt=&#34;Surge Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;直接把 Surge 规则中的 Rule 由 Direct 改成了 Reject。&lt;/p&gt;

&lt;h1 id=&#34;问题追踪&#34;&gt;问题追踪&lt;/h1&gt;

&lt;p&gt;在 2018 年 12 月底的时候，一大早打开电脑查询刚买的 SS 服务。&lt;/p&gt;

&lt;p&gt;刚刚在前几天购买的 SS 流量，每个月 150GB 的限额在短短的 4 天之内就耗了将近 95GB，就在 1 月 1 日元旦当天就耗了接近 75GB，要知道，我并不只有 AgentNEO 一家的流量服务，相对来说在 ping test 上其还不如 Shadowsocks 家的好，所以理论上规则命中也应该是后者的，而且就算我用 A 服务看小电影也不至于这么多流量消耗。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9tRs9vh.png&#34; alt=&#34;AgentNEO 流量面板&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在最初看到这个统计数据之后，我一度怀疑是他们网站的流量统计有问题。&lt;/p&gt;

&lt;p&gt;后续几天，我实际上对流量耗损比较关注，有一天注意到，Surge 的流量监控速率一直持续不断的显示达五六百 KB/s 的下载流量，但是我知道自己当时并没有下载任何东西。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/nWz8JAt.png&#34; alt=&#34;Surge Menu Bar&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开 Surge Dashboard，看到如下的情形：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9kVX27V.png&#34; alt=&#34;Surge Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到当时在持续不断的进行下载动作的进程名称是 &lt;code&gt;com.apple.Safari.SafeBrowsing.Service&lt;/code&gt;，看请求地址是 safebrowsing.googleapis.com。&lt;/p&gt;

&lt;p&gt;从进程名字来看应该是 Safari 和安全流量相关的服务，通过 Snitch 的数据库查到对其的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Safari has built-in support for Google’s Safe Browsing service to identify fraudulent and unsafe websites. Right before Safari navigates to a certain website, the website gets checked for possible security concerns using Google’s Safe Browsing online database. Accessing the online database requires connections to Google servers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说的大概是该服务是针对 Safari 浏览器启用的，在 Safari 要帮你导航到下一级页面的时候，会识别该页面是否是欺诈🐶或者不安全⚠️的网站，我们在 Safari 的 Security 菜单中可以找到启用关于欺诈网站的检测功能的开关。以我本机上看到的内容如下&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Safari uses Tencent Safe Browsing and Google Safe Browsing to identify fraudulent websites.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大概意思就是 Safari 使用腾讯的安全浏览服务和 Google 的安全浏览服务来鉴别欺诈网站，腾讯应该是本地化的产物。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wEhv8iu.png&#34; alt=&#34;Little Snitch Network Monitor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过针对该进程的出口请求 host 也可以验证这一点，该进程发起的网络请求会有如下两个 host 出口：
1. safebrowsing.googleapis.com
2. safebrowsing.urlsec.qq.com&lt;/p&gt;

&lt;p&gt;其实在 iOS 设备上也有同样的进程来做这件事情，抓包有时候也能捕捉到这两个请求（国行）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/g9JCPdU.jpg&#34; alt=&#34;iPhone 上的 Safebrowsing&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而这次出问题的就是 google 提供的欺诈网站特征库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/BtfvMIV.png&#34; alt=&#34;Little Snitch Network Monitor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;尝试关闭 Surge 作为系统流量代理之后，看到 Activity Monitor 中进程又开始了下载，如下图所示，只是连接请求主体从原来 Surge 切换到了独立进程而已（Surge 会接管网络流量，因此之前该任务的下载会算到 Surge 的头上），但是针对该 host 的下载任务一致持续不断。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;说起来，Little Snitch Network Monitor 这款软件也是当时为了查流量丢失问题，才买的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SUT5qQC.png&#34; alt=&#34;Little Snitch Network Monitor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在我关闭 Surge 作为代理之前，可以看到该进程大概在 7 个小时之内耗了 12.4 GB 的流量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Gnxc4bB.png&#34; alt=&#34;Little Snitch Network Monitor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在网络上目前未看到针对 safebrowsing 进程的大量讨论，国内论坛 &lt;a href=&#34;https://www.v2ex.com/t/404025&#34;&gt;V2EX&lt;/a&gt; 里也看到有人遇到该问题。&lt;/p&gt;

&lt;p&gt;目前暂时不清楚是官方 Bug 还是我电脑安装了什么插件或者软件导致。暂时先停掉使用 Safari 了，用 Chrome 用上一段时间之后再用 Snitch 看下情况吧。&lt;/p&gt;

&lt;p&gt;另一方面，因为不放心，在 Surge 的自定义规则中加了一条：
    NAME,com.apple.Safari.SafeBrowsing.Service,DIRECT&lt;/p&gt;

&lt;p&gt;针对该进程的所有流量都直连，不用代理了。 后续有任何进展会更新到 Blog 中。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>在 Swift Framework 中使用 C 文件的过程探索</title>
      <link>https://hechen.xyz/post/swift-and-modules/</link>
      <pubDate>Thu, 03 Jan 2019 21:19:24 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/swift-and-modules/</guid>
      
        <description>

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我们在开发线上诊断工具需求的时候，是以单个 Pod 的形式提供支持，并且代码文件中只有纯 Swift 文件，但是其中需要用到系统的 C 库的一些功能，本次就是使用了系统 C 库中 &lt;code&gt;resolv.h&lt;/code&gt; 这个文件来进行 DNS 解析所用。&lt;/p&gt;

&lt;p&gt;当后期 Pod 功能完善之后，在 Example 工程中也已经编译通过之后，接入主项目中之后遇到了下面这个编译错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ADh0sy6.png&#34; alt=&#34;Error When Compile&#34; /&gt;&lt;/p&gt;

&lt;p&gt;具体文字错误信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;/Users/chen/Repos/Work/ZHDiagnosisTool/ZHDiagnosisTool/Classes/Core/Network/ZHDiagnosisTool-Network-Header.h:8:10: 
    Include of non-modular header inside framework module &#39;Diagnosis.ZHDiagnosisTool_Network_Header&#39;: &#39;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.1.sdk/usr/include/resolv.h&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概的意思就是在 Umbrella Header 中加入的 Bridging header 指定了 include 一个 C 文件，而该 C 文件本身并不是  Modular Header， 因此编译无法通过。这就涉及了目前 iOS 生态中普遍使用的 Modules 概念。&lt;/p&gt;

&lt;h2 id=&#34;几个概念&#34;&gt;几个概念&lt;/h2&gt;

&lt;h3 id=&#34;modules&#34;&gt;Modules&lt;/h3&gt;

&lt;p&gt;Modules 的概念是 XCode 5 带到 iOS 开发者面前的，从那时起 LLVM 编译器就已经内在支持了，具体关于其历史在 &lt;a href=&#34;https://onevcat.com/2013/06/new-in-xcode5-and-objc/&#34;&gt;WWDC 2013 Session笔记 - Xcode5和ObjC新特性&lt;/a&gt; 这篇文章中已经讲解的非常详细了，不再赘述，总结一句话就是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Modules 是被引入 LLVM 层面的，用以解决之前 C/C++ 系中 #include 和 #import 带来的引用泛滥以及编译时间过长的问题的一种手段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;尤其是在 Swift 引入之后，Module 的概念应该已经深入人心。大家可能已经习惯直接使用 @import 来引用某个 Module，或者其中某个功能单元。尤其是使用 CocoaPods 集成开发的时候，其内部实际上也是做了一些 module 的工作，在 Pods 目录中充斥着 &lt;code&gt;.modulemap&lt;/code&gt; 的身影，想必大家经常看到。&lt;/p&gt;

&lt;p&gt;而 一个 module 的属性是由定义它的 &lt;code&gt;.modulemap&lt;/code&gt; 文件来决定的，其简单语法大概如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;module module_name [system] {
    header &amp;quot;header.h&amp;quot;
    link &amp;quot;linked_library&amp;quot;
    export *
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对其中 &lt;a href=&#34;https://clang.llvm.org/docs/Modules.html#module-map-language&#34;&gt;Modules 的语法&lt;/a&gt;感兴趣，可以到 Clang 的官方文档下通读下，你肯定会对 Modules 这一套有更清楚的认识。&lt;/p&gt;

&lt;h3 id=&#34;umbrella-header&#34;&gt;Umbrella Header&lt;/h3&gt;

&lt;p&gt;说起来，Umbrella Header 是在 Framework 的概念被引入的，你可以理解为一个模块均存在一个 Umbrella Header 用来将那些你想暴露给模块外界调用的头文件包裹在一起。避免使用者在使用该模块的时候需要手动输入多个 Header 的一种解决方案。 其实 Mac 端很早就有这个概念，iOS 中特指 iOS 8 开始官方加入 Dynamic Framework 以后的概念。&lt;/p&gt;

&lt;p&gt;如下所示，没有 Umbrella Header 的情况下你需要将所有需要引入的头文件依次写出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;XYZModule/XYZCustomCell.h&amp;gt;
#import &amp;lt;XYZModule/XYZCustomView.h&amp;gt;
#import &amp;lt;XYZModule/XYZCustomViewController.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用了 Umbrella Header 之后，你只需要下面一行即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-objc&#34;&gt;#import &amp;lt;XYZModule/XYZModule.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，还存在 umbrella framework，感兴趣大家可以到&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC&#34;&gt;官方文档&lt;/a&gt;下观看。&lt;/p&gt;

&lt;h3 id=&#34;bridging-header&#34;&gt;Bridging-Header&lt;/h3&gt;

&lt;p&gt;桥接文件是在 Swift 推出之后，Apple 引入iOS 生态的用以桥接 Swift 和 Objective-C 相互调用的一种方式 （Mix and Match），如下图所示，如果在 Swift 中想使用 Objective-C 类定义的内容，就需要建立 Bridging Header，然后在其中定义你想要暴露的 OC 头文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YwqHEKJ.png&#34; alt=&#34;Bridging Header&#34; /&gt;&lt;/p&gt;

&lt;p&gt;具体的操作在&lt;a href=&#34;https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_objective-c_into_swift&#34;&gt;官方文档&lt;/a&gt;有针对在同一个 App Target 和在同一个 Framework 内两种情况均有说明。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在梳理这些概念的过程中，发现自己之前对桥接文件有个误区，如果你在 App 的主 Target 中需要进行 OC 和 Swift 的混编，使用 Bridging Header 是必选，如果你是在同一个 Framework 中进行的混编，Bridging-Header 是并不需要的，你需要做的只是在 Umbrella Header 里加入你想暴露给 Swift 文件使用的 OC 头文件即可，之前自己一直是显式的建立一个 Bridging-Header，然后在 Umbrella Header 中引入该头文件，想来这种方式只是将你想暴露在外的头文件进行了二次包裹而已，因为 Cocoapods 是将所有 public header 均加入到 umbrella header 里了，因此单个 framework 内部开发，即使没有 bridge header 也是能够将符号暴露给 Swift 的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;cocoapods&#34;&gt;Cocoapods&lt;/h3&gt;

&lt;p&gt;我们每次执行 &lt;code&gt;pod install&lt;/code&gt; 的时候，如果你使用 &lt;code&gt;—verbose&lt;/code&gt; 来看详细安装过程就能看到，针对每一个将要被安装的 Pod 均会执行生成 module map 和 umbrella header 这两个阶段，如下所示部分 Install 指令的代码，代码位于 &lt;code&gt;lib/cocoapods/installer/xcode/pods_project_generator/aggregate_target_installer.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def install!
       UI.message &amp;quot;- Installing target `#{target.name}` #{target.platform}&amp;quot; do
       native_target = add_target
       create_support_files_dir
       create_support_files_group
       create_xcconfig_file(native_target)
       if target.host_requires_frameworks?
          create_info_plist_file(target.info_plist_path, native_target, target.version, target.platform)
    	    create_module_map(native_target)
          create_umbrella_header(native_target)
       elsif target.uses_swift?
          create_module_map(native_target)
    			create_umbrella_header(native_target)
       end
      
     # Some Code
     # Some Code
     # Some Code      
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明确，Cocoapods 在 install 某个 Pod 的时候会执行创建 module map 文件以及 umbrella header 文件的工作。详细的代码大家可以直接到 Cocoapods 源码下  &lt;code&gt;lib/cocoapods/generator&lt;/code&gt; 目录下看，分别是 &lt;code&gt;module_map.rb&lt;/code&gt; 和 &lt;code&gt;umbrella_header.rb&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;其中在各自文件的注释部分也有针对生成文件的说明，比如 &lt;code&gt;module_map.rb&lt;/code&gt; 中说明了 module map 的作用，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Generates LLVM module map files. A module map file is generated for each Pod and for each Pod target definition that is built as a framework. It specifies a different umbrella header than usual to avoid name conflicts with existing headers of the podspec.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 &lt;code&gt;umbrella_header.rb&lt;/code&gt; 中说明了 umbrella header 的作用，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Generates an umbrella header file for clang modules, which are used by dynamic frameworks on iOS 8 and OSX 10.10 under the hood. If the target is a +PodTarget+, then the umbrella header is required to make all public headers in a convenient manner available without the need to write out header declarations for every library header.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;问题原因&#34;&gt;问题原因&lt;/h2&gt;

&lt;p&gt;首先解答：为什么 Example 工程能够编译通过 而用了主工程是无法编译通过？&lt;/p&gt;

&lt;p&gt;因为目前主工程都要求我们自行开发的 pod 以动态 framework 的形式参与，但是在 Example 工程开发的时候我们的 &lt;code&gt;podfile&lt;/code&gt; 并未指定 &lt;code&gt;use_frameworks!&lt;/code&gt; 用以产出动态 framework，因此未暴露出该问题，也就是说只有以 framework 的形式的 module 才会有该问题，准确的说，应该是 &lt;code&gt;Dynamic Framework&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;了解了以上概念之后，我们再来看我们的问题，首先我们的问题是在 framework 内部调用系统 C 库代码出现的问题，从 Xcode 的报错，我们知道我们通过 bridging header 引入的 C 文件并不以 module 的形式存在，因此编译器报错。&lt;/p&gt;

&lt;h2 id=&#34;解决过程&#34;&gt;解决过程&lt;/h2&gt;

&lt;p&gt;其实吧，大家都能想到，使用 Objective-C 做个封装，或者干脆直接调用 C 文件的类用 OC 重写不就完了么，可是如果下次你再遇到了呢？ 或者要改造了一个纯 Swift 库呢？知其所以然，才能避免再次落坑吧。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;因为 Objective-C 自身编译器是帮你做了 modular 化的，当然，如果你选择了前者，还有个限制，你并不能把上面 C 的头文件放到你的 Objective-C 的头文件中，因为本质上，最后这个头文件还是要暴露给 Umbrella Header 的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，能否允许编译器支持在 module 中引入非 modular 的头文件呢？&lt;/p&gt;

&lt;p&gt;Xcode 在 build setting 中提供了  &lt;code&gt;Allow Non-modular Includes In Framework Modules&lt;/code&gt; 来控制是否允许在当前 framework 中支持非 modular 头文件引入，其并不适用于纯 Swift 项目，而且即使适用，其会导致所有用到该 framework 的大的编译单元都不能再使用 module 形式引入头文件了，也就是必须适用平坦式的 &lt;code&gt;#include &amp;quot;&amp;quot;&lt;/code&gt; 形式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/S4i2chx.png&#34; alt=&#34;Build Setting&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，通过只能从根源上来解决该问题了，既然需要引入的文件是 modular header，我们就要想办法来将其包裹为 module。 在查找解决方案的过程中发现，就在 Swift 刚推出的时候，大家已经遇到这个问题了，遇到最多的就是&lt;code&gt;CommonCrypto&lt;/code&gt; 经常被使用到的 C 库，常见的 MD5 计算就是其提供的 API，但是在前几年官方并未将该动态库 module 化，因此导致你无法在 Swift 文件中直接使用类似 &lt;code&gt;#import &amp;lt;CommonCrypto/CommonCrypto.h&amp;gt;&lt;/code&gt; 这种写法。自然而言多了很多解决方案，如下出自 StackOverflow 上 &lt;a href=&#34;https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785&#34;&gt;Importing CommonCrypto in a Swift framework&lt;/a&gt; 的帖子下面就提供了多种解决方案：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;还是那句话，你是可以通过 Objective-C 做桥接来达到同样效果的。毕竟 Swift 本身就是一门心思想抛开 C 的历史包袱，因此想拥有一个纯纯的 Swift 代码不沾染一点 C 文件气息，你就要做一些工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中根本问题就是为 &lt;code&gt;CommonCrypto&lt;/code&gt; 这个 C 编译单元定义 module，上面也提到了 LLVM 是通过 &lt;code&gt;modulemap&lt;/code&gt; 文件来识别的，所以只要通过 &lt;code&gt;.modulemap&lt;/code&gt; 来定义即可，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    module CommonCrypto [system] {
        header &amp;quot;/usr/include/CommonCrypto/CommonCrypto.h&amp;quot;
        export *
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义的 modulemap 自然可以放到任意目录，只要让编译单元在编译的时候能够搜索的到即可，Xcode 选项的 Build Settings 下的 Swift Compiler - Search Paths 。添加 .modulemap 文件所在路径即可。在编译的时候 LLVM 自然会查找到 .modulemap 文件自动生成 Module 信息。你此时就可以在使用  CommonCrypto 的地方使用 modular header 了。&lt;/p&gt;

&lt;p&gt;过了几年之后，官方才将该库定义为 module，在 Xcode 自带的 iOS SDK 中 &lt;code&gt;/usr/include/CommonCrypto&lt;/code&gt; 下可以看到 &lt;code&gt;module.modulemap&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module CommonCrypto [system] [extern_c] {
      umbrella header &amp;quot;CommonCrypto.h&amp;quot;
      export *
      module * { export * }
      
      module Error {
          header &amp;quot;CommonCryptoError.h&amp;quot;
          export *
      }
      
      module Random {
          header &amp;quot;CommonRandom.h&amp;quot;
          export *
      }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大家也注意到了在 CommonCrypto 的同级目录中实际上还有很多的系统 C 库代码，并且也有一个 module.modulemap 文件，我裁剪一段代码大家看下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Compression [system] [extern_c] {
    header &amp;quot;compression.h&amp;quot;
    export *
    link &amp;quot;compression&amp;quot;
}
    
module Darwin [system] [extern_c] [no_undeclared_includes] {
    // Headers that are repeatedly included, and therefore should not be
    	// assigned to any given module.
    	exclude header &amp;quot;_structs.h&amp;quot;
    	exclude header &amp;quot;sys/_structs.h&amp;quot;
    
    	// C standard library
    	module C {
    		textual header &amp;quot;assert.h&amp;quot;
    
    	  module setjmp {
    			header &amp;quot;setjmp.h&amp;quot;
    			export *
    		}
    
    		module signal {
    			header &amp;quot;signal.h&amp;quot;
    			export *
    		}
    
    		module stdio {
    			header &amp;quot;stdio.h&amp;quot;
    			export *
    		}
    }
    
    module zlib [system] [extern_c] {
    	header &amp;quot;zlib.h&amp;quot;
    	export *
    	link &amp;quot;z&amp;quot;
    }
    
    module SQLite3 [system] [extern_c] {
    	header &amp;quot;sqlite3.h&amp;quot;
    	link &amp;quot;sqlite3&amp;quot;
    	explicit module Ext {
    		header &amp;quot;sqlite3ext.h&amp;quot;
    		export *
    	}
    	export *
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是为什么我们在 Swift 代码里可以直接使用类似 &lt;code&gt;import Darwin.C.stdio&lt;/code&gt; 写法的原因。但是还是存在一些 C 库并没有被定义为 module，而本次用来做 DNS 解析的 &lt;code&gt;resolv.h&lt;/code&gt; 就是其中一员。&lt;/p&gt;

&lt;p&gt;具体到我们解决思路里来看就是要解决 modulemap 如何定义，如何和我们目前使用的 cocoapods 整合的问题了。既然是在作为 pod 进行开发，自然是需要将 module map 文件加入到 pod 的代码管理中去。比如将其放置于单个 pod 根目录下，然后在 podspec 中配置好路径以便编译的时候 Swift Search Paths 中有它。自然，我们可以建立 resolv.modulemap 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;module Resolv [system] {
    header &amp;quot;/usr/include/resolv.h&amp;quot;
    export *
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在对应的 podspec 文件中配置 build setting 中的参数，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s.subspec &#39;Core&#39; do |core|
    core.source_files   = [&#39;ZHDiagnosisTool/Classes/Core/**/*&#39;] 
    core.preserve_paths = &#39;ZHDiagnosisTool/Classes/Core/ModuleMap&#39;
    core.pod_target_xcconfig = {
        &#39;SWIFT_INCLUDE_PATHS[sdk=macosx*]&#39;           =&amp;gt; &#39;$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap&#39;,
        &#39;SWIFT_INCLUDE_PATHS[sdk=iphoneos*]&#39;         =&amp;gt; &#39;$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap&#39;,
        &#39;SWIFT_INCLUDE_PATHS[sdk=iphonesimulator*]&#39;  =&amp;gt; &#39;$(PODS_ROOT)/ZHDiagnosisTool/Classes/Core/ModuleMap&#39;,
      }
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是，问题出在 PODS_ROOTS 这个路径上，如果我们进行本地开发，该路径就是 Cocoapods 执行完毕之后生成的临时 Pods 目录，并不是原始 podspec 文件所在的地方，而官方也表明了，不会对这种 Local Pods 特定提供一个环境变量来获取， 如下链接可以看到：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/CocoaPods/CocoaPods/issues/809&#34;&gt;local pod development on a project that includes libraries · Issue #809 · CocoaPods/CocoaPods&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如图中，指定 $(PODS_ROOT) 路径实际上在开发 Local Pod 的时候就会找不到，所以就需要按照上面链接中的方式自行手动拼接路径，所以，我们尽可能不用 PODS_ROOT 这个路径，需要另外找一个不会因为 Pod 位置而变化的路径。&lt;/p&gt;

&lt;p&gt;最终参考了以下 repo 中工程的解决方案，&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/onmyway133/Arcane&#34;&gt;onmyway133/Arcane&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中作者使用 Pod 的 script phase 来完成 .modulemap 的操作，这样会更加灵活。&lt;/p&gt;

&lt;p&gt;这样，针对我们自己本次的需求来看，.podspec 中的 script 如下所写即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Create
FRAMEWORK_DIR=&amp;quot;${BUILT_PRODUCTS_DIR}/RESOLV.framework&amp;quot;
          
if [ -d &amp;quot;${FRAMEWORK_DIR}&amp;quot; ]; then
    echo &amp;quot;${FRAMEWORK_DIR} already exists, so skipping the rest of the script.&amp;quot;
    exit 0
fi
          
mkdir -p &amp;quot;${FRAMEWORK_DIR}/Modules&amp;quot;
          
echo &amp;quot;module RESOLV [system] {
    header \&amp;quot;${SDKROOT}/usr/include/resolv.h\&amp;quot;
    export *
}&amp;quot; &amp;gt; &amp;quot;${FRAMEWORK_DIR}/Modules/module.modulemap&amp;quot;
               
    
# Generate fake header...
[ -d &amp;quot;${FRAMEWORK_DIR}/Headers&amp;quot; ] || mkdir &amp;quot;${FRAMEWORK_DIR}/Headers&amp;quot;
touch &amp;quot;${FRAMEWORK_DIR}/Headers/resolv.h&amp;quot;
    
# Soft link C header to local framework Headers
ln -sf &amp;quot;${SDKROOT}/usr/include/resolv.h&amp;quot; &amp;quot;${FRAMEWORK_DIR}/Headers/resolv.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次在编译运行前，我们会自行创建一个 &lt;code&gt;Resolv.framework&lt;/code&gt;，其中 Header 目录中我们放一个空白文件并且软链接到真正想要链接的头文件上，然后在该 framework 中创建 modulemap 文件。&lt;/p&gt;

&lt;p&gt;之后，我们在 .podspec 中指定 script phase 为编译前即可，如下所示，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;s.script_phase = {
    :name =&amp;gt; &#39;Resolv&#39;,
    :script =&amp;gt; script_above,
    :execution_position =&amp;gt; :before_compile
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，通过 &lt;code&gt;Resolv.framework&lt;/code&gt; 的桥接，Swift 代码中就可以直接通过 &lt;code&gt;import RESOLV&lt;/code&gt; 来使用了。当然，链接这一环你可以通过以下两种形式达到：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接在 podspec 文件中指定依赖，如 &lt;code&gt;core.library = &amp;quot;resolv&amp;quot;&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 &lt;code&gt;.modulemap&lt;/code&gt; 文件中显式的 link，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;module Resolv [system] {
header &amp;quot;/usr/include/resolv.h&amp;quot;
link &amp;quot;resolv&amp;quot;
export *
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而且通过将 module map 文件放置于 product 产出目录这里也解决了路径指定的问题，因为 product folder 是默认在编译的搜索路径下的。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总结来看，就是想要在纯 Swift 的项目中引入系统 C 库文件（这里指的是未被 modular 化的文件，因为有些 C 文件已经被系统默认封装成了 module 了）。以上只是一些简单的概念讲解，整个编译系统以及套件都是长时间不断演化的结果，这里也只是简单的讲述，有一些概念实际上也只是点到为止，大家如果感兴趣可以多找一些相关资料阅读下，亲自试一试。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://llvm.org/devmtg/2012-11/Gregor-Modules.pdf&#34;&gt;Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/LLVM&#34;&gt;LLVM - 维基百科，自由的百科全书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://clang.llvm.org/docs/Modules.html#introduction&#34;&gt;Modules - Clang 8 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://onevcat.com/2013/06/new-in-xcode5-and-objc/&#34;&gt;WWDC 2013 Session笔记 - Xcode5和ObjC新特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework/37125785#37125785&#34;&gt;Importing CommonCrypto in a Swift framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://forums.developer.apple.com/thread/46477&#34;&gt;Adding CommonCrypto to custom Swift framework |Apple Developer Forums&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://theswiftdev.com/2018/01/15/how-to-call-c-code-from-swift/&#34;&gt;How to call C code from Swift - The.Swift.Dev.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/swift-and-ios-writing/using-a-c-library-inside-a-swift-framework-d041d7b701d9/&#34;&gt;Using a C library inside a Swift framework - Swift and iOS Writing - Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>UserDefaults and Keychain</title>
      <link>https://hechen.xyz/post/userdefaults-and-keychain/</link>
      <pubDate>Fri, 21 Dec 2018 14:30:50 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/userdefaults-and-keychain/</guid>
      
        <description>

&lt;p&gt;Apple 提供了几种持久化方案，其中 UserDefaults 和 Keychain 是 App 开发过程中使用频率最高的方案，而且从以往和同事的探讨过程中发现对这两个概念中有一些细节还是理解不太透彻，因此本文会针对这二者展开讲一讲。&lt;/p&gt;

&lt;h2 id=&#34;userdefaults&#34;&gt;UserDefaults&lt;/h2&gt;

&lt;p&gt;首先，阅读完 Apple 关于 UserDefaults 一节的文档描述之后，我觉得有两个需要注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;UserDefaults 的构成&lt;/li&gt;
&lt;li&gt;UserDefaults 的目的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;userdefaults-构成&#34;&gt;UserDefaults 构成&lt;/h3&gt;

&lt;p&gt;我们可以看看具体 UserDefaults 存储的地方，如下图，我们在应用中写入 Demo 数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wq9onOa.png&#34; alt=&#34;Write Key-Value to UserDefaults&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打印 Library 路径，在 Finder 中打开路径:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/65ybYX6.png&#34; alt=&#34;Library&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如下展示内容，可以看到在 Preferences 目录中存在某个文件，例如该 App Library 目录下存放的文件为 &lt;code&gt;app.chen.ios.PersistenceDemo.plist&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ChqnDJa.png&#34; alt=&#34;Cache&#34; /&gt;
&lt;img src=&#34;https://i.imgur.com/cPvlFdR.png&#34; alt=&#34;Preferences&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该 plist 内容如图所示，即为我们之前在 App 中写入的 Key-Value。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/shdXoZN.png&#34; alt=&#34;plist&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以这也证明了，我们针对 UserDefaults 的读写实质上是针对 plist 文件的读写。&lt;/p&gt;

&lt;p&gt;iOS 系统会自动帮你做 &lt;code&gt;plist&lt;/code&gt; 文件的读入以及 Cache，根据情况会把你在内存中所做的操作同步到 &lt;code&gt;plist&lt;/code&gt; 文件（UserDefaults 同步到内存是同步的，同步到 Database 是异步的， iOS 8 开始，会有一个常驻进程 &lt;code&gt;cfprefsd&lt;/code&gt; 来负责同步）。&lt;/p&gt;

&lt;p&gt;所以你会看有iOS 面试题目会问题： 系统的 &lt;code&gt;UserDefaults&lt;/code&gt; 的本质以及和 plist 文件的直接读写的区别？（这题目太 TM 偏了。。。）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. When you set a default value, it’s changed synchronously within your process, and asynchronously to persistent storage and other processes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以，实质上，你是可以直接针对 UserDefaults 的最终产物 plist 文件进行操作的，当然，这是有风险的，而且无法保障正常使用的。官方在文档中也提醒了开发者。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Don’t try to access the preferences subsystem directly. Modifying preference property list files may result in loss of changes, delay of reflecting changes, and app crashes. To configure preferences, use the defaults command-line utility in macOS instead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那既然本质上 UserDefaults 是使用 plist 文件进行存储，那也要求了我们能存储的 Value 只能支持 &lt;code&gt;plist&lt;/code&gt; 所支持的格式，例如 &lt;code&gt;String&lt;/code&gt;，&lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;Data&lt;/code&gt;，&lt;code&gt;Date&lt;/code&gt; 等，当然如果你要存储自定义的类，其需要遵守 &lt;code&gt;Codable&lt;/code&gt; 协议（实质也是要归档为 &lt;code&gt;Data&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cxWHfvS.png&#34; alt=&#34;plist&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;userdefaults-目的&#34;&gt;UserDefaults 目的&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;The defaults system allows an app to customize its behavior to match a user’s preferences. For example, you can allow users to specify their preferred units of measurement or media playback speed. Apps store these preferences by assigning values to a set of parameters in a user’s defaults database.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般我们在 &lt;code&gt;UserDefaults&lt;/code&gt; 存储的数据都是用户的某些配置项，不因为用户使用过程中出现意外而丢失，比如是否开启了日夜间模式了，是否开启了大图模式了等等。或者存储一些对安全方面不敏感的数据&lt;/p&gt;

&lt;p&gt;不建议往 &lt;code&gt;UserDefaults&lt;/code&gt; 里存储较大的数据，例如直接存储一张图片。而对于这种需要存储较大文件的需求，你可以将文件本身存储到本地，而 &lt;code&gt;UserDefaults&lt;/code&gt; 里只存储该文件的路径。&lt;/p&gt;

&lt;p&gt;毕竟在 App 启动之后，UserDefaults 会进行 IO ，读取本地 plist 文件，因此一定程度上，也会较少 App 启动之后 UserDefaults API 针对 &lt;code&gt;plist&lt;/code&gt; 文件 IO 的时间，纯属个人揣测，没有经过实验验证。&lt;/p&gt;

&lt;h3 id=&#34;关于-extension-中-userdefaults-的应用&#34;&gt;关于 Extension 中 UserDefaults 的应用&lt;/h3&gt;

&lt;p&gt;iOS 上 Extension 和 Host App 之间做数据共享也是通过 UserDefaults，开启 App Group 之后，这二者就可以修改同一份配置。具体 Extension 和 Host App 之间的内在关系可以先看下 Apple 文档。本质上如下所示，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cZFlz6o.png&#34; alt=&#34;app_extensions_container_restrictions&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Extension 和 Host App 之间通过 Shared Container 来做数据共享，该 SharedContainer 私有，因此不存在于单一 App 的沙盒内。应该是系统会单独开辟一块空间用以做共享数据的存储。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After you enable app groups, an app extension and its containing app can both use the NSUserDefaults API to share access to user preferences. To enable this sharing, use the initWithSuiteName: method to instantiate a new NSUserDefaults object, passing in the identifier of the shared group.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为 UserDefaults 既然是暴露在本地能够访问的文件当中的，因此不要在 UserDefaults 里存储任何 Security-Sensitive 的数据。 如果要存储保密级别较高的数据，就要用到另外一种持久化方案 ── Keychain&lt;/p&gt;

&lt;h2 id=&#34;keychain&#34;&gt;Keychain&lt;/h2&gt;

&lt;p&gt;关于 Keychain，是 Apple 提供给开发者用来存储 Security-Sensitive 的数据了，比如登录密码，用户标识，加密数据等等。 官方示意图如下，其实中间 Keychain 的 API 还进行了 Decrypt 和 Encrypt 的动作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/tvA4lV3.png&#34; alt=&#34;Keychain services API&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Apple 提供的 Keychain API 大部分都是 C 语言写成，使用起来相对不便，因此基本上我们都会使用二次加工过的库，比如知乎用的就是 SMKeychain。&lt;/p&gt;

&lt;p&gt;Keychain 中的数据完全交由系统保管并加密过( AES 128 in GCM (Galois/Counter Mode))的，因此能够保证安全性。&lt;/p&gt;

&lt;p&gt;如果对加密这一块感兴趣，可以看下&lt;a href=&#34;https://www.apple.com/business/site/docs/iOS_Security_Guide.pdf&#34;&gt;苹果的白皮书&lt;/a&gt;中 Keychain data protection 这一节。&lt;/p&gt;

&lt;p&gt;另外，Keychain 的数据并不存放在 App 的 Sanbox 中，即使删除了 App，资料依然保存在 keychain 中。如果重新安装了app，还可以从 keychain 获取数据。&lt;/p&gt;

&lt;h3 id=&#34;同一个-app-内部共享&#34;&gt;同一个 App 内部共享&lt;/h3&gt;

&lt;p&gt;类似 UserDefaults ，Keychain 也支持 Extension 和 host app 之间的共享，需要在每个 Target 的 Capability 下开启 Keychain Sharing 功能，并且设置为同一个 Group。&lt;/p&gt;

&lt;h3 id=&#34;不同-app-之间共享&#34;&gt;不同 App 之间共享&lt;/h3&gt;

&lt;p&gt;和 UserDefaults 不同的是，Keychain 的数据是可以跨 App 获取的，但是限于一个开发者的 App，也就是需要确保这些 App 所属的 Team ID 是相同的。&lt;/p&gt;

&lt;p&gt;这个也是App 进行 SSO 登录的基础，比如知乎日报使用知乎主 App 登录也是基于此原理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/0L2MA23.png&#34; alt=&#34;shared items&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在需要进行 Keychain 共享的 App 内开启 Keychain Sharing 的能力，所属同一个 Team ID 下的 App 本身都可以读取该 Keychain 的内容，类似于 AppGroup，这里也会产生 Keychain Group。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Allows this application to share passwords from its keychain with other applications made by your team.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/DJsInJb.png&#34; alt=&#34;Keychain Sharing&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;参考文档&#34;&gt;参考文档&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/foundation/userdefaults&#34;&gt;https://developer.apple.com/documentation/foundation/userdefaults&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/&#34;&gt;https://www.reddit.com/r/jailbreak/comments/2qpqi9/ios_812_has_protection_against_plist_file_editing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://iphonedevwiki.net/index.php/PreferenceBundles&#34;&gt;http://iphonedevwiki.net/index.php/PreferenceBundles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html&#34;&gt;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/security/keychain_services&#34;&gt;https://developer.apple.com/documentation/security/keychain_services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/soffes/SAMKeychain&#34;&gt;https://github.com/soffes/SAMKeychain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps&#34;&gt;https://developer.apple.com/documentation/security/keychain_services/keychain_items/sharing_access_to_keychain_items_among_a_collection_of_apps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>如何做 Send to 2Do 的书签</title>
      <link>https://hechen.xyz/post/send-to-2do/</link>
      <pubDate>Mon, 26 Nov 2018 14:59:50 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/send-to-2do/</guid>
      
        <description>&lt;p&gt;使用鼠标拖拽下面这个链接到你的 Favorites Bar 上，&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;javascript:window.location=&#34;&gt;Send to 2Do&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后编辑地址，将其替换为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:window.location=&#39;twodo://x-callback-url/add?task=&#39;+encodeURIComponent(document.title)+&#39;&amp;amp;note=&#39;+encodeURIComponent(window.location)+&#39;&amp;amp;action=url:&#39;+encodeURIComponent(window.location)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/7M0xN1g.jpg&#34; alt=&#34;Change Value&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以，其实还是在触发调用 URL Scheme，其中&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;document.title&lt;/code&gt; 为标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.location&lt;/code&gt; 为当前页面链接&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们知道 Things 的 URL Scheme 为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;things:///add?title=iamtitle&amp;amp;notes=iamnotes&amp;amp;when=tomorrow&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;比如你可以把链接内容改为支持 Send To Things：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:window.location=&#39;things:///add?title=&#39;+encodeURIComponent(document.title)+&#39;&amp;amp;notes=&#39;+encodeURIComponent(window.location)+&#39;&amp;amp;when=today&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及 Send To OmniFocus ，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;javascript:window.location=&#39;omnifocus:///add?note=&#39;+encodeURIComponent(window.location)+&#39;&amp;amp;name=&#39;+encodeURIComponent(document.title)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接去 &lt;a href=&#34;http://people.omnigroup.com/kc/OmniFocus/SendToOmniFocusBookmarklet.html&#34;&gt;OmniFocus 页面&lt;/a&gt; 用相同方式把起已经设置好正确 Value 的链接拖到上方工具条上即可。&lt;/p&gt;

&lt;p&gt;如果你找不到 Favorites Bar，点击 Safari 菜单栏上的 View 菜单就能看到（中文系统叫视图）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZBqkn4Z.jpg&#34; alt=&#34;Favorites Bar&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>阅读流程</title>
      <link>https://hechen.xyz/post/reading-process/</link>
      <pubDate>Tue, 16 Oct 2018 17:01:44 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/reading-process/</guid>
      
        <description>

&lt;p&gt;最近统一了一下自己的阅读流程，更新一下，具体用到的工具有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;DEVONThink Pro&lt;/li&gt;
&lt;li&gt;PDFExpert&lt;/li&gt;
&lt;li&gt;MarginNote&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中 1 是输入和归档源，3 是输出源。 大概就是如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SrcVtP1.png&#34; alt=&#34;Reading Process&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;采集素材&#34;&gt;采集素材&lt;/h2&gt;

&lt;p&gt;在平时浏览网页的时候，看到自己喜欢的文章之后，想进行一些标记或者做笔记，大概有几个选择：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;印象笔记直接 clip 当前网页，之后在印象笔记里进行阅读或者标记&lt;/li&gt;
&lt;li&gt;放进稍后读服务中，比如 Pocket 或者 Instapaper 等；&lt;/li&gt;
&lt;li&gt;用 Safari 自带的 Save as PDF 之后再用单独的 PDF 工具查看；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而最近几个月，因为 MarginNote 3 的发布，由于其提供的大纲脑图的自动生成，给我提供了一种便利的拆书功能，因此会把平时看到的文章都归集到一处来看。&lt;/p&gt;

&lt;p&gt;借助 DEVONthink 的 Clip To DEVONthink 的插件可以很方便的把文章归集到 DEONThink 中，最主要的是因为它能保存 WebArchive，即使后续文章被删除也没关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Kw7CoBl.png&#34; alt=&#34;Clip To DEVONthink&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当按下 Cmmd + S 进行归档之后，DEVONThink 对应 Group 里就会把该原始页面保存起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/m3jM9kx.png&#34; alt=&#34;DEVONthink&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于 WebArchive 无法做 Highlight 标记，这时候就用到了 DEVONthink 提供的 OCR 功能，将 WebArchive 提取为 PDF 文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YxEsN2G.png&#34; alt=&#34;WebArchive To PDF&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;二次加工处理&#34;&gt;二次加工处理&lt;/h2&gt;

&lt;p&gt;当你使用 DEVONthink 生成 PDF 之后，就可以直接用其自带的 PDF 阅读工具进行阅读了，它默认提供工具已经完全满足，不过我想利用 MarginNote 来阅读，因此这时候你可以选择直接发送到 MarginNote 来阅读。&lt;/p&gt;

&lt;p&gt;其实更多时候，我会选择先使用 PDF Expert 进行 PDF 文件的裁剪，因为大多数时候网页正文内容两侧留白太多，想裁剪掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/8I8UcFY.png&#34; alt=&#34;PDF With Margin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;裁剪掉多余的部分之后，pdf 文件就可读性也会极大提高。
&lt;img src=&#34;https://i.imgur.com/1CwG33x.png&#34; alt=&#34;Final PDF&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;阅读输出&#34;&gt;阅读输出&lt;/h2&gt;

&lt;p&gt;到了这一步，我们就可以把文档导入到 MarginNote 中，如图所示：
&lt;img src=&#34;https://i.imgur.com/DmADrxk.png&#34; alt=&#34;MarginNote Import&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;strong&gt;Add to Study&lt;/strong&gt;，将自己的标记和笔记生成笔记本，MarginNote 强大就在于能够很好的自动帮你把重点归集到一起，生成脑图关联，你还可以针对某个部分做笔记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9uvu95H.png&#34; alt=&#34;MarginNote Add To Study&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而且很多时候，我们看一篇文章很大可能会展开这个主题，比如看下该文章下给的参考链接，这些往往都是同样主题的内容，我们希望相关的文章能够整体归集到一个笔记本下。MarginNote 可以很方便做到，比如下图，我在阅读 Apple 官方 URL Session Programming Guide 的时候会查看很多相关文章，也都是相关内容，我会把笔记整理在一起。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kIvn6v8.png&#34; alt=&#34;MarginNote Note Group&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我单独在 MarginNote 里建了一个 Folder ，叫 Article。专门阅读我从 DEVONthink 中采集到的文章。阅读完毕，还可以将阅读笔记归档，MarginNote 支持分享到 印象笔记，Word 或者 DEVONthink 进行归档。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yyQ3pOr.png&#34; alt=&#34;Export&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到了这里，基本上对我来讲一个 输入 ── 处理 ── 阅读 ── 输出 的整个流程就结束了，基本上是一个闭环。&lt;/p&gt;

&lt;p&gt;上面提到的三个工具，均有 iOS 版本，也就意味着即使拿着手机也能够不破坏整个阅读环节，不过其中 DEVONthink 提供的 iOS 版本是没办法进行 WebArchive 向 PDF 的转换的，处理这一步最后还是得放在 Mac 端处理，不过解决了输入和输出也就意味着随时随地可以捕获想看的内容放到稍后读列表，然后自动同步到 Mac 端进行处理，然后在 MarginNote 对应的 iOS 版本，平时在家的时候还是习惯用 iPad Pro 查看，体验也不错。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ZJsdxyS.jpg&#34; alt=&#34;iPad MarginNote&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>三个简单步骤让你测试使用系统单例的代码</title>
      <link>https://hechen.xyz/post/testing-swift-code-that-uses-system-singletons-in-3-easy-steps/</link>
      <pubDate>Tue, 17 Jul 2018 17:09:57 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/testing-swift-code-that-uses-system-singletons-in-3-easy-steps/</guid>
      
        <description>

&lt;p&gt;大部分在 Apple 平台开发的 App 都会依赖基于单例的 API。从 UIScreen 到 UIApplication，再到 NSBundle，而 Foundation，UIKit 以及 AppKit 里到处充斥着静态的 API。&lt;/p&gt;

&lt;p&gt;尽管单例非常方便，并且随时随地都可以很轻易的获取到特定的 API，但是当它们一旦要面临代码解耦和测试的时候就会出现挑战。单例同时也是平时遇到 Bug 里最常见的一种，在单例中状态会以共享的方式终结，那些针对状态做的变更并不能很好的广播到整个系统层面。&lt;/p&gt;

&lt;p&gt;然而，尽管我们能够重构自己的代码，让它们只在真正需求的地方使用单例，我们针对系统 API 也做不了太多。但是，好消息是，这里有一些技巧让你使用系统单例的代码依然变得容易管理和测试。&lt;/p&gt;

&lt;p&gt;让我们看一些使用了 URLSession.shared 单例的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class DataLoader {
    enum Result {
        case data(Data)
        case error(Error)
    }

    func load(from url: URL, completionHandler: @escaping (Result) -&amp;gt; Void) {
        let task = URLSession.shared.dataTask(with: url) { (data, response, error) in
            if let error = error {
                return completionHandler(.error(error))
            }

            completionHandler(.data(data ?? Data()))
        }

        task.resume()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个 &lt;strong&gt;DataLoader&lt;/strong&gt; 现在就变得很难测试，因为它内部会自主调用共享的 URL Session 来执行一个网络调用。这就需要我们为测试代码中增加一些等待和超时代码，然后很快这部分代码就会变得糟糕和不稳定。&lt;/p&gt;

&lt;h3 id=&#34;抽象成一个协议&#34;&gt;抽象成一个协议&lt;/h3&gt;

&lt;p&gt;我们第一个任务就是把我们需要的 URLSession 的部分移到一个协议里，这样我们在测试中也能够很容易的进行 mock。在作者的&lt;a href=&#34;http://www.ustream.tv/recorded/101118612&#34;&gt;一次 talk&lt;/a&gt;中作者建议尽可能的避免 mock，尽管它是一种很好的策略。但是当你和系统的单例打交道的时候，mock 就是一个增加可预测性的重要工具。&lt;/p&gt;

&lt;p&gt;让我们创建一个 &lt;strong&gt;NetworkEngine&lt;/strong&gt; 协议，然后让 URLSession 符合它:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
protocol NetworkEngine {
    typealias Handler = (Data?, URLResponse?, Error?) -&amp;gt; Void

    func performRequest(for url: URL, completionHandler: @escaping Handler)
}

extension URLSession: NetworkEngine {
    typealias Handler = NetworkEngine.Handler

    func performRequest(for url: URL, completionHandler: @escaping Handler) {
        let task = dataTask(with: url, completionHandler: completionHandler)
        task.resume()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所见，我们使得 &lt;strong&gt;URLSessionDataTask&lt;/strong&gt; 成了 &lt;strong&gt;URLSession&lt;/strong&gt; 的一个实现细节。这样，我们就避免了在测试代码中不得不创建不同的 mock ，而只需要关注 NetworkEngine 就行。&lt;/p&gt;

&lt;h3 id=&#34;协议中把单例作为默认值&#34;&gt;协议中把单例作为默认值&lt;/h3&gt;

&lt;p&gt;现在，让我们更新我们的 &lt;strong&gt;DataLoader&lt;/strong&gt; 来使用新的 NetworkEngine 协议，把它作为依赖项注入。我们把 URLSession.shared 作为默认参数传递，以此做到了向后兼容并且和之前一样方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class DataLoader {
    enum Result {
        case data(Data)
        case error(Error)
    }

    private let engine: NetworkEngine

    init(engine: NetworkEngine = URLSession.shared) {
        self.engine = engine
    }

    func load(from url: URL, completionHandler: @escaping (Result) -&amp;gt; Void) {
        engine.performRequest(for: url) { (data, response, error) in
            if let error = error {
                return completionHandler(.error(error))
            }

            completionHandler(.data(data ?? Data()))
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过使用默认参数，我们依然可以像之前一样很容易的生成 &lt;strong&gt;DataLoader&lt;/strong&gt;，而不需要提供一个 &lt;strong&gt;NetworkEngine&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&#34;在你的测试中-mock-协议&#34;&gt;在你的测试中 Mock 协议&lt;/h3&gt;

&lt;p&gt;最后，让我们写个测试，在这里我们通过 mock &lt;strong&gt;NetworkEngine&lt;/strong&gt; 使得我们的测试快速，可预测并且容易维护。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
func testLoadingData() {
    class NetworkEngineMock: NetworkEngine {
        typealias Handler = NetworkEngine.Handler 

        var requestedURL: URL?

        func performRequest(for url: URL, completionHandler: @escaping Handler) {
            requestedURL = url

            let data = “Hello world”.data(using: .utf8)
            completionHandler(data, nil, nil)
        }
    }

    let engine = NetworkEngineMock()
    let loader = DataLoader(engine: engine)

    var result: DataLoader.Result?
    let url = URL(string: “my/API”)!
    loader.load(from: url) { result = $0 }

    XCTAssertEqual(engine.requestedURL, url)
    XCTAssertEqual(result, .data(“Hello world”.data(using: .utf8)!))
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上所见，作者试图让 mock 尽可能的简单。不需要创建包含大量逻辑的复杂 mock，你只需要让自己的代码返回一些 hardcode 的值通常是一个好主意，这样，你能够在自己的测试中进行断言。然而，风险就是你可能最后测试的是自己的 mock 而不是生产环境的代码。&lt;/p&gt;

&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;

&lt;p&gt;我们现在通过以下三个步骤让这些依然方便的使用了系统的单例可被测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;抽象协议&lt;/li&gt;
&lt;li&gt;协议中把单例作为默认值&lt;/li&gt;
&lt;li&gt;在你的测试中 Mock 该协议&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>避免在 Swift 中使用单例</title>
      <link>https://hechen.xyz/post/avoiding-singletons-in-swift/</link>
      <pubDate>Mon, 16 Jul 2018 17:34:36 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/avoiding-singletons-in-swift/</guid>
      
        <description>

&lt;p&gt;“我知道单例不好，但是&amp;hellip;”，这是开发者常常在讨论代码的时候会提到的。貌似社区大家有共识 ── 单例不好。但是同时，包括 Apple 和第三方的 Swift 开发者还是在 App 内部或者共享的 frameworks 里不断在用它们。&lt;/p&gt;

&lt;p&gt;这周，让我们好好看一看单例的问题到底在哪里，探索更多的技巧以便我们日常能够避免使用它们。这就开始吧！&lt;/p&gt;

&lt;h3 id=&#34;为什么单例这么流行&#34;&gt;为什么单例这么流行？&lt;/h3&gt;

&lt;p&gt;首先一点我们要想的是问问自己，为什么单例这么流行？热过大多数开发者都认同，单例应该被避免的话，为什么它们还不断的出现呢？&lt;/p&gt;

&lt;p&gt;我认为有两部分原因。&lt;/p&gt;

&lt;p&gt;我觉得日常开发 Apple 平台上的 App 时候大量使用单例，最大的原因是苹果自己也在经常的用。作为第三方开发者来讲，我们常常会把 Apple 的做法作为最佳实践来用，任何 Apple 自己常常使用的模式在社区也会发展的很迅速。&lt;/p&gt;

&lt;p&gt;这个谜题的第二个原因是单例非常方便。单例因为它可以在任何地方获取到，因而经常会扮演一个获取特定核心值或者对象的快捷方式。可以看下下面这个例子，在这个例子中，我们想在 &lt;strong&gt;ProfileViewController&lt;/strong&gt; 中展示当前登录用户的名字，同时当某个按钮按下的时候，退登当前用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class ProfileViewController: UIViewController {
    private lazy var nameLabel = UILabel()
    override func viewDidLoad() {
        super.viewDidLoad()
        nameLabel.text = UserManager.shared.currentUser?.name
    }
    private func handleLogOutButtonTap() {
        UserManager.shared.logOut()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上面这样，把一个 UserManager 单例的用户和账户处理的功能封装起来，确实很方便（而且很常见！），那这种模式的使用到底不好在哪里呢？&lt;/p&gt;

&lt;h3 id=&#34;为什么单例会很糟糕&#34;&gt;为什么单例会很糟糕？&lt;/h3&gt;

&lt;p&gt;当讨论类似模式和架构这些东西的时候，很容易陷入一个特别理论化的圈套。虽然让我们的代码理论上“正确”，遵循最佳实践和原则是很美好的，但是现实经常会很受打击，我们需要寻找一些中间方案。&lt;/p&gt;

&lt;p&gt;所以，关于单例引起的实质性问题是什么呢？为什么它们要应该被避免呢？这里我倾向于三个原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;这些单例是全局的可变的共享状态。它们的状态是在整个 App 里自动共享的，因此当其状态发生不可预期的变化的时候，Bug 也就可能开始发生了；&lt;/li&gt;
&lt;li&gt;单例之间的关系以及依赖这些单例的代码常常不那么好定义。因为单例是如此方便和容易获得，大量的使用它们常常会导致很难维护&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&#34;&gt;面条式代码&lt;/a&gt;，这些代码中对象和对象之间没有清晰的隔离；&lt;/li&gt;
&lt;li&gt;管理这些单例的生命周期非常的难。因为单例本身会在应用的整个生命周期内存活，管理它们就变得异常困难，因此常常会不得不依赖可选值来跟踪值的变化。这也使得依赖单例的代码变得很难测试，因为你没法在一个测试 case 里把状态重置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在我们前面的 &lt;strong&gt;ProfileViewController&lt;/strong&gt; 的例子中，我们已经看到了有这三个问题的信号出现。首先它依赖 UserManager 导致这二者关系很不清晰，其次，它不得不让 currentUser 作为可选值出现，因为我们没办法在编译期就能够确定视图控制器实际上出现的时候这个数据一定在。听起来就感觉要有 bug 发生的感觉 😬!&lt;/p&gt;

&lt;h3 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h3&gt;

&lt;p&gt;相对于使用 &lt;strong&gt;ProfileViewController&lt;/strong&gt; 通过单例来获取它所需的依赖项，我们要在其初始化方法中将依赖项传入。这里我们是将当前的 User 作为非可选传入的，同样，传入一个 &lt;strong&gt;LogOutService&lt;/strong&gt; 来进行登出操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class ProfileViewController: UIViewController {
    private let user: User
    private let logOutService: LogOutService
    private lazy var nameLabel = UILabel()
    init(user: User, logOutService: LogOutService) {
        self.user = user
        self.logOutService = logOutService
        super.init(nibName: nil, bundle: nil)
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        nameLabel.text = user.name
    }
    private func handleLogOutButtonTap() {
        logOutService.logOut()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，代码就会变得更加清晰，并且容易管理。我们的代码现在安全的依赖其 Model，并且有一个清晰的 API 进行登出的交互。一般情况下，将各种单例以及管理器重构成清晰分离的服务能够使得一个 App 的核心对象之间的关系更加清晰。&lt;/p&gt;

&lt;h3 id=&#34;services&#34;&gt;Services&lt;/h3&gt;

&lt;p&gt;举个例子，让我们更近一些来看下 &lt;strong&gt;LogOutService&lt;/strong&gt; 这个类是如何实现的。它内部也对其依赖的服务使用了依赖注入，并且提供了一个优雅的，定义清晰的 API 来只做一件事情 ── 登出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class LogOutService {
    private let user: User
    private let networkService: NetworkService
    private let navigationService: NavigationService
    init(user: User,
         networkService: NetworkService,
         navigationService: NavigationService) {
        self.user = user
        self.networkService = networkService
        self.navigationService = navigationService
    }
    func logOut() {
        networkService.request(.logout(user)) { [weak self] in
            self?.navigationService.showLoginScreen()
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;翻新&#34;&gt;翻新&lt;/h3&gt;

&lt;p&gt;从一个重度使用单例的设置到完全使用服务，依赖注入以及本地状态来改造会非常的困难，会花费大量时间。而且，会很难认为花大量时间在这上面是合理的，而且有些时候可能会需要一次更大规模的重构才行。&lt;/p&gt;

&lt;p&gt;谢天谢地，我们可以使用相近的技术，在&lt;a href=&#34;https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps&#34;&gt;Testing Swift code that uses system singletons in 3 easy steps&lt;/a&gt;这篇文章中也使用到过，其允许我们可以以一种非常容易的方式单例开始。和很多其他解决方案类似 ── 协议来救场！&lt;/p&gt;

&lt;p&gt;我们不是一次性重构所有的单例，而是创建 Service 类，我们可以很简单的把我们的 Service 定义成 Protocol，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
protocol LogOutService {
    func logOut()
}
protocol NetworkService {
    func request(_ endpoint: Endpoint, completionHandler: @escaping () -&amp;gt; Void)
}
protocol NavigationService {
    func showLoginScreen()
    func showProfile(for user: User)
    ...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就能通过将单例符合我们新创建的 Service 协议来使其翻新为一堆 Service。在很多情况下，我们甚至不需要改变任何实现，只是简单的传递它们 shared 实例作为一个 Service 即可。&lt;/p&gt;

&lt;p&gt;同样的技巧也能够被用作重构我们 app 中其他核心对象，那些对象我们也许也都正在以某种单例形式在使用着，例如使用 AppDelegate 来做导航。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
extension UserManager: LoginService, LogOutService {}
extension AppDelegate: NavigationService {
    func showLoginScreen() {
        navigationController.viewControllers = [
            LoginViewController(
                loginService: UserManager.shared,
                navigationService: self
            )
        ]
    }
    func showProfile(for user: User) {
        let viewController = ProfileViewController(
            user: user,
            logOutService: UserManager.shared
        )
        navigationController.pushViewController(viewController, animated: true)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们现在通过使用依赖注入以及 Service 的方式，开始使得我们工程处在 Singleton free 的状态，而不需要进行特别巨大的工程改造和重写。接下来我们就能够使用 Service 或者其他类型的 API 逐个替换掉单例，比如说使用&lt;a href=&#34;https://www.swiftbysundell.com/posts/replacing-legacy-code-using-swift-protocols&#34;&gt;这篇博文&lt;/a&gt;中的技巧。&lt;/p&gt;

&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;

&lt;p&gt;单例也不是都是不好的，只是在很多情况下，它们会引发一系列问题，这些问题可以通过使用依赖注入的方式为你程序里的对象建立良好的关系来解决。&lt;/p&gt;

&lt;p&gt;如果你现在正在开发的 App 里在使用大量的单例，那你一定也在经历或者已经经历过它们所带来的 bug 了吧。希望这篇文章能够给你一些灵感让你没有那么慌乱的开始远离它们。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Swift 中几种不同的依赖注入方式</title>
      <link>https://hechen.xyz/post/different-flavors-of-dependency-injection-in-swift/</link>
      <pubDate>Mon, 16 Jul 2018 13:57:24 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/different-flavors-of-dependency-injection-in-swift/</guid>
      
        <description>

&lt;p&gt;在之前的几篇博客中，我们已经了解了几种使用依赖注入方式使得某个 swift app 拥有一个更加解耦可测试的架构。比如在 &lt;a href=&#34;http://hechen.xyz/2017/11/19/Dependency-injection-using-factories-in-Swift/&#34;&gt;在 Swift 中使用工厂模式进行依赖注入&lt;/a&gt; 中和工厂模式结合，以及在&lt;a href=&#34;http://hechen.xyz/2018/07/16/Avoiding-singletons-in-Swift/&#34;&gt;避免在 Swift 中使用单例&lt;/a&gt;中替换程序中的单例对象等方式进行依赖注入。&lt;/p&gt;

&lt;p&gt;到目前为止，大部分我的博文以及例子中都使用了基于初始化的依赖注入方式。然而，就像大部分的编程技巧一样，还有很多 “口味” 的进行依赖注入的方式 ── 每一种都有其优缺点。 这周，让我们来看看其中三种方式以及如何在 Swift 中使用它们。&lt;/p&gt;

&lt;h3 id=&#34;基于初始化方法&#34;&gt;基于初始化方法&lt;/h3&gt;

&lt;p&gt;让我们快速回顾一下用的最为广泛的依赖注入方式 ── initializer-based。这个想法是在某个类被初始化的时候传入其所需的依赖的方式。这种形式最大的好处就是，它保证了能够立即满足该类完成其功能所需要的所有东西。&lt;/p&gt;

&lt;p&gt;让我们建一个类 ── FileLoader 来从磁盘加载文件。为了实现该 Loader 的功能，需要两个依赖项，系统所提供的实例对象 ── &lt;strong&gt;FileManager&lt;/strong&gt; 和 &lt;strong&gt;Cache&lt;/strong&gt;。使用基于初始化的依赖注入的执行代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class FileLoader {
    private let fileManager: FileManager
    private let cache: Cache

    init(fileManager: FileManager = .default,
         cache: Cache = .init()) {
        self.fileManager = fileManager
        self.cache = cache
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以关注下初始化方法里默认参数的设置，其可以避免每次都需要自行创建的问题。这样能够简化我们在生产环境下使用 &lt;strong&gt;FileLoader&lt;/strong&gt; 类创建文件加载器的工作，而且也能够能够传入 mock 数据或者我们的测试代码中的创建的实例进行测试。&lt;/p&gt;

&lt;h3 id=&#34;基于属性&#34;&gt;基于属性&lt;/h3&gt;

&lt;p&gt;虽然前一种基于初始化的依赖注入形式常常给我们自定义类带来很多好处，但是有时候，当你不得不继承自某个系统类的时候会遇到一些困难。其中一个例子就是，当我们构建 view controller，尤其是你在使用 XIB 以及 Storyboard 类定义它们的时候，因为此时你不再能够掌控它们的初始化方法了。&lt;/p&gt;

&lt;p&gt;对于这些情况，基于属性的依赖注入方式是一个更好的选择。相对于初始化的时候进行对象的依赖项注入，基于属性的形式可以在之后通过简单的赋值来做到，其能够让你减少模板代码的书写，尤其是在你确实没有必要进行注入的时候能够有更好的默认实现。&lt;/p&gt;

&lt;p&gt;让我们再来看一个例子，在这个例子中，我们在构建一个 &lt;strong&gt;PhotoEditorViewController&lt;/strong&gt; ，这个视图控制器使得用户编辑它们照片库中的图片。为了达到这个功能，该视图控制器需要用到系统提供的 PHPhotoLibrary 类型的一个实例（该类本身是一个单例）以及我们自己实现的类 &lt;strong&gt;PhotoEditorEngine&lt;/strong&gt; 的一个实例。那为了不通过自定义初始化方法进行依赖注入的话，我们可以创建一些具有默认值的可变属性，例如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class PhotoEditorViewController: UIViewController {
    var library: PhotoLibrary = PHPhotoLibrary.shared()
    var engine = PhotoEditorEngine()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://www.swiftbysundell.com/posts/testing-swift-code-that-uses-system-singletons-in-3-easy-steps&#34;&gt;Testing Swift code that uses system singletons in 3 easy steps&lt;/a&gt; 这篇文章中的手法，通过使用一个协议提供一个更为抽象的 &lt;strong&gt;PhotoLibrary&lt;/strong&gt; 接口来获取系统的图片库。这样会使得测试和 Mock 数据特别的容易。&lt;/p&gt;

&lt;p&gt;上面这些工作比较好的是我们依然能够通过简单的给视图控制器来赋值，从而在我们的测试中简单的注入 Mock 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class PhotoEditorViewControllerTests: XCTestCase {
    func testApplyingBlackAndWhiteFilter() {
        let viewController = PhotoEditorViewController()

        // Assign a mock photo library to gain complete control over
        // what photos are stored in it
        let library = PhotoLibraryMock()
        library.photos = [TestPhotoFactory.photoWithColor(.red)]
        viewController.library = library

        // Run our testing commands
        viewController.selectPhoto(atIndex: 0)
        viewController.apply(filter: .blackAndWhite)
        viewController.savePhoto()

        // Assert that the outcome is correct
        XCTAssertTrue(photoIsBlackAndWhite(library.photos[0]))
    }   
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基于参数&#34;&gt;基于参数&lt;/h3&gt;

&lt;p&gt;最后一种，让我们来看下基于参数的依赖注入形式。这种方式尤其在你想让旧有代码更加可测试，而不需要对现存的结构进行更多改动的时候尤其有效。&lt;/p&gt;

&lt;p&gt;许多时候，我们仅需要某个特定的依赖项一次，或者我们仅仅需要在某些特定条件下进行 mock。不需要改变某个对象的初始化方法或者暴露可变属性（通常都不是一个好主意），我们可以开发出一个接受一个依赖项作为参数的特定 API。&lt;/p&gt;

&lt;p&gt;让我们看一个 &lt;strong&gt;NoteManager&lt;/strong&gt; 类，该类是某个笔记类应用的一部分。它的工作就是管理所有用户已经书写的笔记，提供一个 API 让用户能够查询笔记。考虑到这个操作可能耗时（如果用户有许多笔记，通常情况下是这样），我们把该动作正常放置于一个后台线程执行，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class NoteManager {
    func loadNotes(matching query: String,
                   completionHandler: @escaping ([Note]) -&amp;gt; Void) {
        DispatchQueue.global(qos: .userInitiated).async {
            let database = self.loadDatabase()
            let notes = database.filter { note in
                return note.matches(query: query)
            }

            completionHandler(notes)
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管上面的代码在我们的生产环境里也算是一个很好的解决方案，但在测试中我们正常情况下是想避免一些异步代码的，尽可能的平行化以避免 &lt;a href=&#34;https://www.swiftbysundell.com/posts/reducing-flakiness-in-swift-tests&#34;&gt;flakiness&lt;/a&gt;. 如果要类似于基于初始化或者基于属性的依赖注入能够指定一个显式的队列提供给 NoteManager 来用的方式，需要对该类进行很多改变，这是我们在当下无法做或者不愿意做的。&lt;/p&gt;

&lt;p&gt;这时候，基于参数的依赖注入方式的实现就能够达到。相对于不得不对整个类进行重构，我们通过插入队列相关代码使得 &lt;code&gt;loadNotes&lt;/code&gt; 方法在该队列上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class NoteManager {
    func loadNotes(matching query: String,
                   on queue: DispatchQueue = .global(qos: .userInitiated),
                   completionHandler: @escaping ([Note]) -&amp;gt; Void) {
        queue.async {
            let database = self.loadDatabase()
            let notes = database.filter { note in
                return note.matches(query: query)
            }

            completionHandler(notes)
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就使得我们能够很容易的在测试代码中使用某个定制的我们可等待的队列。这样也几乎使得我们把上面的接口转变成了一个同步接口，使得一切变得更加容易和可预测。&lt;/p&gt;

&lt;p&gt;另外一个基于参数的依赖注入的使用案例是当你想测试某个静态的 API 的时候。因为静态的 API 我们是不存在初始化方法的，同时我们理想情况下也是不应该维护任何静态的状态的，那基于参数的依赖注入方式就是一个很好的选择。让我们看一个静态的类 &lt;strong&gt;MessageSender&lt;/strong&gt;， 该类当前依赖某个单例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class MessageSender {
    static func send(_ message: Message, to user: User) throws {
        Database.shared.insert(message)

        let data: Data = try wrap(message)
        let endpoint = Endpoint.sendMessage(to: user)
        NetworkManager.shared.post(data, to: endpoint.url)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，一个长远的解决方案更可能是重构 &lt;strong&gt;MessageSender&lt;/strong&gt; 这个类，让它变成一个非静态的，能够在其所有被使用的地方被正确的注入依赖。但是基于我们能够更容易的测试它（比如，重现或者验证某个 Bug），我们能简单的使用参数作为依赖项进行注入，而不是基于某个单例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
class MessageSender {
    static func send(_ message: Message,
                     to user: User,
                     database: Database = .shared,
                     networkManager: NetworkManager = .shared) throws {
        database.insert(message)

        let data: Data = try wrap(message)
        let endpoint = Endpoint.sendMessage(to: user)
        networkManager.post(data, to: endpoint.url)
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们又再次使用了缺省的参数，不仅仅更加方便而已，更重要的是，能够在 100% 向后兼容的情况下为我们的代码增加测试支持。&lt;/p&gt;

&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;所以，哪一种依赖注入的方案是最好的呢？就像大部分时候一样，我的答案很无聊的： 看情况！我在该博客中所视图去做的一件事情就是针对某个特定问题给出需要不同的解决方案。原因很简单，我真的不相信又所谓银弹的存在。我认为，按照我们意愿具备多个工具或者对于特定技巧的多种解决方案能够使我们变得更好，在写代码的时候也能够游刃有余。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>那些我恢复 Mac 系统之后要安装的 Apps</title>
      <link>https://hechen.xyz/post/my-favorite-mac-apps/</link>
      <pubDate>Wed, 11 Jul 2018 12:58:37 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/my-favorite-mac-apps/</guid>
      
        <description>

&lt;p&gt;记录一下自己常用的 Mac Apps，每次重装之后到了用的时候发现忘记安装了(不是每次都用 TimeMachine 恢复)，而且强烈简易大家如果某个 App 有对应的独立安装版本的话，购买其独立安装版本为好，沙盒环境以及和 Apple ID 绑定的特性就使得功能性以及灵活度大减。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;更新时间 2018-10-07
更换图床，更新图片&lt;/p&gt;

&lt;p&gt;更新时间 2018-08-10
不久前，已经订阅了一年的 Setapp，发现上面好多 App 自己都之前买过了，Sigh！
如果你使用 Ulysses 或者 MoneyWiz 3.0 的话，订阅 Setapp 就会非常的值得！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/q3yToeZ.png&#34; alt=&#34;Mac Apps&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;办公工具&#34;&gt;办公工具&lt;/h2&gt;

&lt;p&gt;离开这些工具，貌似无法办公的。&lt;/p&gt;

&lt;h3 id=&#34;airmail&#34;&gt;AirMail&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/airmail-3/id918858936?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/19ADIxn.jpg&#34; alt=&#34;AirMai&#34; /&gt;&lt;/p&gt;

&lt;p&gt;邮箱客户端，看中 AirMail 主要是因为其强大的第三方服务集成。&lt;/p&gt;

&lt;h3 id=&#34;slack&#34;&gt;Slack&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/slack/id803453959?mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/W1wtsje.jpg&#34; alt=&#34;Slack&#34; /&gt;&lt;/p&gt;

&lt;p&gt;公司的日常沟通交流主要战场，其实整个操作体验我是不太适应的，不过它强大在第三方服务的集成上，可以做很多自动化的事情。&lt;/p&gt;

&lt;h3 id=&#34;fantastical-2&#34;&gt;Fantastical 2&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://flexibits.com/fantastical&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1naxpaM.jpg&#34; alt=&#34;Fantastical&#34; /&gt;&lt;/p&gt;

&lt;p&gt;日历工具，查看满满的一屏幕日程，你会感觉很舒服的。&lt;/p&gt;

&lt;h4 id=&#34;tunnelblick&#34;&gt;Tunnelblick&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://tunnelblick.net/downloads.html&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ghIEHNQ.png&#34; alt=&#34;Tunnelblick-menu&#34; /&gt;&lt;/p&gt;

&lt;p&gt;公司需要使用该 App 来接入办公室网络。远程办公必备。&lt;/p&gt;

&lt;h4 id=&#34;office-三件套&#34;&gt;Office 三件套&lt;/h4&gt;

&lt;p&gt;微软的 Office 三件套，Word，Excel，PowerPoint。 用的频率不高，但是用的时候得有。&lt;/p&gt;

&lt;h2 id=&#34;gtd&#34;&gt;GTD&lt;/h2&gt;

&lt;p&gt;日常 GTD 工具，基本就是各家评测常提起的几款 App。&lt;/p&gt;

&lt;h3 id=&#34;2do&#34;&gt;2Do&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.2doapp.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/st89Smb.jpg&#34; alt=&#34;2Do on Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近才完全转向 2Do，这个 GTD 工具是我最早买入的，但是后来因为其自动化太弱，被打入冷宫。最近几个月又开始捡起来了，吸引我的几个点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Colorful Tab&lt;/li&gt;
&lt;li&gt;Mail AutoCapture&lt;/li&gt;
&lt;li&gt;Smart List&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一点就是，其同步目前稳定的就只能使用 Dropbox 了，在国内基本对大部分人就是个障碍。&lt;/p&gt;

&lt;h3 id=&#34;things-3&#34;&gt;Things 3&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/5ifAVwf.jpg&#34; alt=&#34;Things3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Things 2 之前也有，不过因为功能太简单，基本处于买了看看的状态，后来 Things 3 的出现主要看中它的设计元素。&lt;/p&gt;

&lt;h3 id=&#34;omnifocus-3&#34;&gt;OmniFocus 3&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/D72LM50.jpg&#34; alt=&#34;OmniFocus 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用它最主要的原因是它支持 AppleScript 比较方便。尤其是结合 Keyboard Maestro 来用太方便。比如我会建立一些定时任务，每周五下午下班前自动生成一张周报表单，列出来本周完成的 Task 等。&lt;/p&gt;

&lt;p&gt;最近刚又从 2 升级到 3 代，半价折扣 39.99$&lt;/p&gt;

&lt;p&gt;3 主要将之前 Context 更换为支持多属性的 Tag，也算补充了一个竞争点吧。&lt;/p&gt;

&lt;h2 id=&#34;系统工具&#34;&gt;系统工具&lt;/h2&gt;

&lt;p&gt;基本是系统缺少的或者功能难以满足日常使用的一些 App。&lt;/p&gt;

&lt;h3 id=&#34;1-blocker&#34;&gt;1 Blocker&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/app/id1107421413&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/l3aGI1P.jpg&#34; alt=&#34;1 Blocker&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;istat-menus&#34;&gt;iStat Menus&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://download.bjango.com/istatmenus/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PtO8FNP.jpg&#34; alt=&#34;iStat Menus&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;bartender-3&#34;&gt;Bartender 3&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.macbartender.com/Demo/Bartender%203.zip&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/EnE2fyQ.png&#34; alt=&#34;Bartender&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;surge&#34;&gt;Surge&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://nssurge.com/&#34;&gt;Surge&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近 Yachen Liu 发布了 Surge 3 的 Mac 版本预览版本&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/CNc6AIK.png&#34; alt=&#34;Surge 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实质上是个网络调试工具，但是大部分情况下被用来作为爱国上网工具了。 而且定价策略也是引发了很多口水战，不过商品嘛，如果你觉得不值就不买就行了，不必要想用还骂他定价高，对吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/gkhCynx.png&#34; alt=&#34;Surge Dashboard&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;wallpaper-wizard&#34;&gt;Wallpaper Wizard&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/wallpaper-wizard-2/id1266674560?mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/lYnieJQ.jpg&#34; alt=&#34;Wallpaper Wizard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MacPaw 家的壁纸应用，限时免费的时候入的。&lt;/p&gt;

&lt;h3 id=&#34;tinkertool&#34;&gt;TinkerTool&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.bresink.com/osx/TinkerTool.html&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/YqvFP1Y.png&#34; alt=&#34;TinkerTool&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一个系统增强工具，可以对 Dashboard 和 Docker 等进行定制化修改。&lt;/p&gt;

&lt;h3 id=&#34;capto&#34;&gt;Capto&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.globaldelight.com/capto/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/9QeUc6Z.jpg&#34; alt=&#34;Capto&#34; /&gt;&lt;/p&gt;

&lt;p&gt;截屏和录制视频工具。&lt;/p&gt;

&lt;h2 id=&#34;效率工具&#34;&gt;效率工具&lt;/h2&gt;

&lt;h3 id=&#34;1password-7-for-mac&#34;&gt;1Password 7 for Mac&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://app-updates.agilebits.com/download/OPM7&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/Bb13IZD.jpg&#34; alt=&#34;1Password 7&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;alfred-3&#34;&gt;Alfred 3&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://cachefly.alfredapp.com/Alfred_3.6.2_922.dmg&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/WeFkSYh.jpg&#34; alt=&#34;Alfred&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;launchbar-6&#34;&gt;LaunchBar 6&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.obdev.at/products/launchbar/download.html&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FVgOB3g.png&#34; alt=&#34;LaunchBar&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;bettertouchtool&#34;&gt;BetterTouchTool&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://bettertouchtool.net/releases/BetterTouchTool.zip&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4RfNX0T.jpg&#34; alt=&#34;BetterTouchTool&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;keyboard-maestro&#34;&gt;Keyboard Maestro&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.keyboardmaestro.com/action/download?km-kmi-7-b3&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IOZeiaH.png&#34; alt=&#34;Keyboard Maestro&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;yoink&#34;&gt;Yoink&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://eternalstorms.at/yoink/mac/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/oMcckyM.jpg&#34; alt=&#34;Yoink&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;unclutter&#34;&gt;Unclutter&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://unclutterapp.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/SunNE17.png&#34; alt=&#34;Unclutter&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;toothfairy&#34;&gt;ToothFairy&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/toothfairy/id1191449274?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/2crElmV.jpg&#34; alt=&#34;ToothFairy&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;popclip&#34;&gt;PopClip&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/popclip/id445189367?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qytMbLT.jpg&#34; alt=&#34;PopClip&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;copied&#34;&gt;Copied&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://geo.itunes.apple.com/us/app/copied/id1026349850?ls=1&amp;amp;mt=12&amp;amp;at=1010l8Ju&amp;amp;ct=web&amp;amp;uo=8&amp;amp;at=1010l8Ju&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/hRW1Xoo.jpg&#34; alt=&#34;Copied&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一款剪贴板工具，应该是目前 Mac 上最强大的剪贴板工具了。&lt;/p&gt;

&lt;h2 id=&#34;写作&#34;&gt;写作&lt;/h2&gt;

&lt;h3 id=&#34;day-one&#34;&gt;Day One&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/day-one/id1055511498?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fKmOZa9.jpg&#34; alt=&#34;Day One&#34; /&gt;&lt;/p&gt;

&lt;p&gt;日记应用，之前买了 iOS 和 Mac 双版本，改成订阅之后自动升级为 Plus 会员了，功能已经完全足够。最近的 Premium 会员增加了音频日记以及 Dark Theme 的主题了。&lt;/p&gt;

&lt;h3 id=&#34;ulysses&#34;&gt;Ulysses&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/ulysses/id1225570693?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GBaAJW2.jpg&#34; alt=&#34;Ulysses&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个完全是冲动消费，就是想看看大家捧杀这么狠到底优秀在哪里，说实话其自定义的 Markdown 格式我还是用不太习惯，不过用了每几次。从非订阅用到了订阅&lt;/p&gt;

&lt;h3 id=&#34;mweb&#34;&gt;MWeb&lt;/h3&gt;

&lt;p&gt;推荐安装其非 MAS 版本，&lt;a href=&#34;https://zh.mweb.im/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/fMxRIDB.jpg&#34; alt=&#34;MWeb&#34; /&gt;&lt;/p&gt;

&lt;p&gt;前一阵子刚又升级到了 3.0 版本，虽然 UI 上和 Ulysses 差得远，不过因为本地化做的好，各项服务接入的比较完整，比如图床，静态网站自动生成等都是比较吸引人的地方。&lt;/p&gt;

&lt;h3 id=&#34;notability&#34;&gt;Notability&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/notability/id736189492?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GPiorsk.jpg&#34; alt=&#34;Notability&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;goodnotes&#34;&gt;GoodNotes&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/goodnotes/id1026566364?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-2400x2400bb -2-.jpg&#34; alt=&#34;GoodNotes&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mindnode-5&#34;&gt;MindNode 5&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/mindnode-5/id1289197285?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/1er4hI3.jpg&#34; alt=&#34;MindNode 5&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;阅读&#34;&gt;阅读&lt;/h2&gt;

&lt;h3 id=&#34;devonthink-pro-office&#34;&gt;DEVONThink Pro Office&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.devontechnologies.com/download/products.html&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-07-13-42007085dd.png&#34; alt=&#34;DEVONThink Pro Office&#34; /&gt;&lt;/p&gt;

&lt;p&gt;已经完全把 DENONThink 家的产品作为构建我知识图谱的工具了。必备。&lt;/p&gt;

&lt;h3 id=&#34;reeder-3&#34;&gt;Reeder 3&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/us/app/reeder-3/id880001334?mt=12&amp;amp;uo=4&amp;amp;at=1001lsTF&amp;amp;ct=iOS_detail_share_880001334&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NPLz9Wl.jpg&#34; alt=&#34;Reeder 3&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;marginnote-3&#34;&gt;MarginNote 3&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://marginnote.com/?lang=zh-hans&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/kPu5B0k.jpg&#34; alt=&#34;MarginNote 3&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;

&lt;h3 id=&#34;ide&#34;&gt;IDE&lt;/h3&gt;

&lt;h4 id=&#34;xcode&#34;&gt;Xcode&lt;/h4&gt;

&lt;p&gt;话不多说，老老实实的从 App Store 下载吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NSW9lFo.jpg&#34; alt=&#34;Xcode&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;appcode&#34;&gt;AppCode&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jetbrains.com/objc/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/pdXy6FK.png&#34; alt=&#34;AppCode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;AppCode 强大就强大在 Jetbrain 团队一贯的 Refactor 功能。不过在 15寸 中配 MacBook Pro 上依然会时不时卡顿，不清楚时不时因为其基于 JVM 那一套所致。推荐个人开发者或者项目不太庞大的团队或者个人使用。&lt;/p&gt;

&lt;h3 id=&#34;编辑器&#34;&gt;编辑器&lt;/h3&gt;

&lt;h4 id=&#34;visual-studio-code&#34;&gt;Visual Studio Code&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ExXn0QN.png&#34; alt=&#34;Visual Studio Code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;目前当之无愧最好使的编辑器了，当然可以作为大量脚本语言的轻量 IDE 使用了。&lt;/p&gt;

&lt;h3 id=&#34;代码管理&#34;&gt;代码管理&lt;/h3&gt;

&lt;h4 id=&#34;tower&#34;&gt;Tower&lt;/h4&gt;

&lt;p&gt;Tower 是一款多平台支持的 Git GUI，使用命令行虽然某些程度上比较快，也显得 Geek 范儿，但是在查看 Diff 等功能上确实不太直观，因此一款 Git 的 UI 工具显得很重要。Tower 是一款收费软件，最近 3.0 转为了订阅式。刚订阅了一年基础版再接着用，毕竟切换工具的代价有时候蛮大的。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.git-tower.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/r4FdJaF.jpg&#34; alt=&#34;Microsoft.VisualStudio.Services.Screenshots&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;ohmystar&#34;&gt;OhMyStar&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/us/app/ohmystar2/id1218642292?ls=1&amp;amp;mt=8&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/3NNd0ct.jpg&#34; alt=&#34;OhMyStar 2&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;snippetslab&#34;&gt;SnippetsLab&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/snippetslab/id1006087419?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qd4LQGz.jpg&#34; alt=&#34;SnippetsLab&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;设计&#34;&gt;设计&lt;/h3&gt;

&lt;h4 id=&#34;sketch&#34;&gt;Sketch&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.sketchapp.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/NXGXH8X.jpg&#34; alt=&#34;Sketch&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;sip-for-mac&#34;&gt;Sip for Mac&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://sipapp.io/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/f3NUIHy.jpg&#34; alt=&#34;sip-color-format-mac-2016&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;paintcode&#34;&gt;PaintCode&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.paintcodeapp.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/E7UILLI.png&#34; alt=&#34;PaintCode 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;主要针对一些复杂的设计图形，用代码绘制会非常复杂，比如一个需要使用 Bezier 绘制复杂的图形，如果人工画，费时费力。使用 PaintCode 能够解决这个痛点，支持 Objective-C 和 Swift 两种语言。&lt;/p&gt;

&lt;p&gt;结合 Playground 的话你感受一下。&lt;/p&gt;

&lt;h4 id=&#34;eagle&#34;&gt;Eagle&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/4kEFUi4.png&#34; alt=&#34;Eagle&#34; /&gt;&lt;/p&gt;

&lt;p&gt;设计师用来收集素材所用&lt;/p&gt;

&lt;h3 id=&#34;调试&#34;&gt;调试&lt;/h3&gt;

&lt;h4 id=&#34;charles&#34;&gt;Charles&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.charlesproxy.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/s7LX5NO.png&#34; alt=&#34;Charles&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用公司的序列号，手机版本我也入了，不过在 iOS 生态里其并没有 Mac 上在同等功能上的地位，在 iOS 上我更喜欢使用 surge 或者 Thor 来抓包，而后者的功能基本上目前是市面上最完整的 App 了。 但是在 Mac 平台，Charles 的地位依然无人撼动。&lt;/p&gt;

&lt;h4 id=&#34;paw&#34;&gt;Paw&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://paw.cloud/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/zt7Up5u.jpg&#34; alt=&#34;paw-lg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;强大的 API 调试工具&lt;/p&gt;

&lt;h4 id=&#34;reveal&#34;&gt;Reveal&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://revealapp.com/features/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/ITkfXe6.jpg&#34; alt=&#34;Reveal&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;

&lt;h4 id=&#34;monodraw&#34;&gt;Monodraw&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://monodraw.helftone.com/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/M20TPBn.jpg&#34; alt=&#34;Monodraw&#34; /&gt;&lt;/p&gt;

&lt;p&gt;代码注释加强工具，可以用来对代码进行注释。&lt;/p&gt;

&lt;h4 id=&#34;cutebaby&#34;&gt;CuteBaby&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/GyIzViM.jpg&#34; alt=&#34;CuteBaby&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Model 序列化工具，解决的痛点就是后端给你一个 JSON 结构，你需要自行映射成工程中的类，这个重复工作有时候会让您炸掉，因为有的接口返回的结构复杂，字段繁杂。不过网络上有很多开源的项目其实也可以做到一定程度。&lt;/p&gt;

&lt;h2 id=&#34;社交&#34;&gt;社交&lt;/h2&gt;

&lt;h4 id=&#34;telegram&#34;&gt;Telegram&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://telegram.org/dl/macos&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/cWw9qpK.jpg&#34; alt=&#34;Telegram&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;tweetbot-3&#34;&gt;Tweetbot 3&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://itunes.apple.com/cn/app/tweetbot-3-for-twitter/id1384080005?l=en&amp;amp;mt=12&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yK4hhTr.jpg&#34; alt=&#34;Tweetbot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;其他-1&#34;&gt;其他&lt;/h2&gt;

&lt;h4 id=&#34;rescuetime&#34;&gt;RescueTime&lt;/h4&gt;

&lt;p&gt;买了 Premium 会员，记录我日常在 Mac 上的工作记录。已经记录了大概有 2 年多的数据了，很直观。&lt;/p&gt;

&lt;h4 id=&#34;pcalc&#34;&gt;PCalc&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/PRMDseI.jpg&#34; alt=&#34;PCalc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;也算是老牌的计算器了&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>What is LLVM</title>
      <link>https://hechen.xyz/post/what-is-llvm/</link>
      <pubDate>Tue, 10 Jul 2018 12:05:58 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/what-is-llvm/</guid>
      
        <description>

&lt;h1 id=&#34;什么是-llvm-隐藏在-swift-rust-clang-等语言背后的奥秘&#34;&gt;什么是 LLVM？隐藏在 Swift，Rust，Clang 等语言背后的奥秘&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;了解编译器是如何生成机器原生代码会使得倒腾新语言或者加强已经存在的编程语言变得比以往更加容易了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新的编程语言，针对现存语言的优化如同雨后春笋般产生。 Mozilla 的 &lt;strong&gt;Rust&lt;/strong&gt;， Apple 的 &lt;strong&gt;Swift&lt;/strong&gt;，JetBrain 的 &lt;strong&gt;Kotlin&lt;/strong&gt;等语言给开发者提供了在速度，安全性，便捷性，可移植性以及性能等方面更多的选择。&lt;/p&gt;

&lt;p&gt;为什么是这个时间点呢？一个重大的原因是那些构建具体语言相关的新式工具的出现。在这一堆工具中，最重要的就是 LLVM，其全称是 Low-Level Virtual Machine，它是一个开源项目，其最早是由 Swift 语言的发明人 Chris Lattner 在伊利诺斯州州立大学期间的一个研究项目而来。&lt;/p&gt;

&lt;p&gt;LLVM 不仅仅使得创建新式语言更加容易，也使得针对现存编程语言进行增强完善更加便捷。它提供了一堆工具使得创造语言的过程中需要的那些令人头疼的事情变得自动化：创建一个编译器，输出代码需要适配多平台和架构，编写代码处理语言当中通常都存在的那些比较晦涩的部分，比如异常。LLVM 的自由开发许可使得它可以被自由的作为一个软件组件或者被部署成服务来使用。&lt;/p&gt;

&lt;p&gt;使用了 LLVM 的编程语言花名册种有很多熟悉的名字。Apple 的 Swift 语言使用 LLVM 作为其编译器框架，Rust 语言使用 LLVM 作为其工具链中的一个核心组件。同样，许多编译器也有其 LLVM 版本，例如 Clang，一个 C/C++ 编译器，它是和 LLVM 功能特别相近的一个项目。还有 Kotlin 语言，其名义上是一门 JVM 语言，也正在开发该语言的一个版本： &lt;a href=&#34;https://www.infoworld.com/article/3187370/application-development/kotlin-compiles-directly-to-native-code-via-llvm.html&#34;&gt;Kotlin Native&lt;/a&gt;，其使用 LLVM 编译成机器原生代码。&lt;/p&gt;

&lt;h2 id=&#34;llvm-是什么&#34;&gt;LLVM 是什么&lt;/h2&gt;

&lt;p&gt;LLVM 最核心的功能就是，可以通过编码方式创造机器原生代码。一个开发者可以使用其 API 创造指令，该指令是一种 intermediate representation 格式，简称 IR。之后，LLVM 能够将 IR 编译成独立的二进制文件，或者对其执行即时编译以运行在另外一个程序，例如某编程语言的解释器的上下文中。&lt;/p&gt;

&lt;p&gt;很多编程语言中很常见的结构体或者模式，LLVM 的 API 都提供了原始语义的支持。例如，几乎所有的语言都有函数或者全局变量的概念，LLVM 在其 IR 中把函数和全局变量作为独立元素定义出来，因此你不需要花太多时间和精力来重复造这些特定的轮子，你只需要使用 LLVM 的实现，专注于你的语言最需要关注的地方即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/xIbW9gq.jpg&#34; alt=&#34;一个 LLVM 的 IR 的例证. 右侧是一个简单的 C 程序; 左侧是同样的代码被 Clang 编译器翻译成的 LLVM IR&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;llvm-专为移植性而设计&#34;&gt;LLVM: 专为移植性而设计&lt;/h2&gt;

&lt;p&gt;涉及 LLVM 的一点就是，经常在讨论 C 语言的时候被提及： C 语言有时候会被描述为一门可移植的高阶汇编语言，就是因为其具备能被映射成很接近硬件设备的指令，而且它已经被移植到几乎所有的系统架构上。但是 C 语言只能作为一种可移植的汇编语言实际上也有其副作用，这个确实也不是其设计目标。&lt;/p&gt;

&lt;p&gt;作为对比，LLVM 的 IR 从最初就是被设计作为一个可移植的汇编。体现的第一点就是其提供独立于特定机器架构的语义，例如，integer 类型并不会被限制在特定硬件设备上的最大位数（比如 32 位 或者 64 位）。你可以按照你的需要的位数来创建你所需要的 integer 类型，比如 一个 128 位的 integer。你也不需要担心针对特定处理器指令集来再加工，LLVM 已经为了考虑了这些。&lt;/p&gt;

&lt;p&gt;如果你想看到 LLVM IR 长的什么样子，可以去看一下 &lt;a href=&#34;http://ellcc.org/&#34;&gt;ELLCC 项目&lt;/a&gt;，尝试一下 &lt;a href=&#34;http://ellcc.org/demo/index.cgi&#34;&gt;Demo&lt;/a&gt; 直接使用浏览器将 C 代码转换为 LLVM IR。&lt;/p&gt;

&lt;h2 id=&#34;编程语言是如何使用-llvm-的&#34;&gt;编程语言是如何使用 LLVM 的&lt;/h2&gt;

&lt;p&gt;最常用的场景就是作为某一种语言的编译器前端（ahead-of-time (AOT) compiler），除了如此，LLVM 还有其他很多可能性。&lt;/p&gt;

&lt;h3 id=&#34;使用-llvm-进行即时编译&#34;&gt;使用 LLVM 进行即时编译&lt;/h3&gt;

&lt;p&gt;一些情形需要我们的代码在运行时即时生成，而不是提前编译好。比如 &lt;a href=&#34;https://www.infoworld.com/article/3241107/python/julia-vs-python-julia-language-rises-for-data-science.html?nsdr=true&#34;&gt;Julia 语言&lt;/a&gt;，JIT 编译其代码，因为其需要运行很快，能够使得用户通过交互式解析器（&lt;a href=&#34;https://en.wikipedia.org/wiki/Read–eval–print_loop&#34;&gt;REPL&lt;/a&gt;）或者可交互弹窗来交互。Mono，使用 .Net 实现，能够利用 &lt;a href=&#34;http://www.mono-project.com/docs/advanced/runtime/docs/llvm-backend/&#34;&gt;LLVM 后端编译为机器原生代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.infoworld.com/article/2880767/python/5-projects-push-python-performance.html&#34;&gt;Numba&lt;/a&gt;，一个为 Python 提供的数学计算加速包，JIT 将选择的 Python 函数编译为机器代码。它也能提前编译 Numba 修饰的代码，但是（例如 Julia），Python 由于其解释性语言的特性能够提供快速的开发工作。使用 JIT 编译能够产出比提前编译更好的 Python 的交互工作流。&lt;/p&gt;

&lt;p&gt;其他的语言还有用非传统方式把 LLVM 作为 JIT 来实验的语言，比如 &lt;a href=&#34;https://www.pgcon.org/2017/schedule/events/1092.en.html&#34;&gt;JIT-Compiling SQL Queries in PostgreSQL Using LLVM&lt;/a&gt;，能够达到高达 5 倍的性能提升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/viRT3KE.jpg&#34; alt=&#34;Numba 使用 LLVM 即时编译其数值代码从而加速其执行速度。JIT 加速的 sum2d 函数完成执行比使用常规 Python 代码的实现快大约 139 倍&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;利用-llvm-进行自动化的代码优化&#34;&gt;利用 LLVM 进行自动化的代码优化&lt;/h3&gt;

&lt;p&gt;LLVM 不仅仅是将 IR 编译成原生机器代码。你也可以通过编码引导其进行更大粒度的优化工作，整个工作会贯穿整个链接过程。优化工作可以非常激进，包括对函数进行内联，移除死代码（包含无用的类型声明以及函数参数）或者&lt;a href=&#34;https://en.wikipedia.org/wiki/Loop_unrolling&#34;&gt;展开循环&lt;/a&gt;等。&lt;/p&gt;

&lt;p&gt;这次依然，上面这些你并不需要都自己来做。 LLVM 能够帮你处理这些事情，你也可以按需关闭这些功能。举例来讲，如果你想牺牲一部分性能来减小二进制的大小，你可以使用自己的编译器前端来告知 LLVM 来关闭循环展开。&lt;/p&gt;

&lt;h3 id=&#34;使用-llvm-的领域特定语言&#34;&gt;使用 LLVM 的领域特定语言&lt;/h3&gt;

&lt;p&gt;LLVM 已经被用以为许多跨领域通用计算机语言产生编译器，但是它在生成非常垂直或者解决某些具体问题的语言方面也非常有用。在某些程度上，这才是 LLVM 最闪光的点所在，因为它移除了一大堆创建该语言过程中的单调烦躁的工作，并且使得它表现的更好。&lt;/p&gt;

&lt;p&gt;比如，&lt;a href=&#34;https://github.com/kripken/emscripten&#34;&gt;Emscripten&lt;/a&gt; 项目，采用了 LLVM IR 代码，将其转换成 JavaScript，理论上允许任何具备 LLVM 后端的语言可以导出在浏览器中运行的代码。虽然 Emscripten 的长期计划是能够拥有可生成 WebAssembly 的基于 LLVM 的后端，但是它是一个展示 LLVM 灵活性的很好的例证。&lt;/p&gt;

&lt;p&gt;另外一种 LLVM 可以被使用的方式就是为已存在的编程语言增加特定领域的扩展。Nvidia 使用 LLVM 创造了&lt;a href=&#34;https://developer.nvidia.com/cuda-llvm-compiler&#34;&gt;Nvidia CUDA Compiler&lt;/a&gt;，其能够让编程语言增加针对 CUDA 的原生支持，而不是通过加载某个库来唤起。&lt;/p&gt;

&lt;h2 id=&#34;在多种语言中使用-llvm&#34;&gt;在多种语言中使用 LLVM&lt;/h2&gt;

&lt;p&gt;和 LLVM 打交道的一种典型方式就是找到你很舒服的一种编程语言的代码来体会，当然，这种编程语言要支持 LLVM。&lt;/p&gt;

&lt;p&gt;两种常见选择的语言是 C 和 C++。许多 LLVM 的开发者默认选择这二者之一有以下几个原因：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;LLVM 本身就是 C++ 写的；&lt;/li&gt;
&lt;li&gt;LLVM 的 API 能够在 C 和 C++ 中无缝使用；&lt;/li&gt;
&lt;li&gt;需要语言都倾向于基于 C 和 C++ 进行开发。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;尽管，这两种语言并不是唯一的选择。许多语言能够原生调用 C 库的方法，所以理论上是可以使用这些语言来进行 LLVM 开发的，但是其也有助于在某种语言中实际存在一个库，能够优雅的封装 LLVM 的 API。幸运的是，许多语言和运行时都有这些库，包括 &lt;a href=&#34;https://github.com/Microsoft/LLVMSharp&#34;&gt;C#/.Net/Mono&lt;/a&gt;, &lt;a href=&#34;https://crates.io/crates/llvm-sys&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;https://hackage.haskell.org/package/llvm&#34;&gt;Haskell&lt;/a&gt;, &lt;a href=&#34;https://opam.ocaml.org/packages/llvm/&#34;&gt;OCAML&lt;/a&gt;, &lt;a href=&#34;https://www.npmjs.com/package/llvm-node&#34;&gt;Node.js&lt;/a&gt;, &lt;a href=&#34;https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT&#34;&gt;Go&lt;/a&gt;, 和 &lt;a href=&#34;https://github.com/numba/llvmlite&#34;&gt;Python&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;不过，你需要注意的一点是，这些语言中有一些针对 LLVM 的绑定支持并不完整。以 Python 语言举例，虽然存在多种选择，但是它们都会在完整性和功效性上有差别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LLVM 项目下&lt;a href=&#34;https://github.com/llvm-mirror/llvm/tree/master/bindings/python&#34;&gt;维护有针对 LLVM 的 C 版 API 的绑定集合&lt;/a&gt;，但是它们已经不再被维护了；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.infoworld.com/article/3247799/development-tools/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html&#34;&gt;llvmpy&lt;/a&gt; 在 2015 年停止的维护，这对于任何的软件项目来讲都不是一件好事。在使用 LLVM 的时候更是如此，考虑到每一个版本的 LLVM 所带来的变化数量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/numba/llvmlite&#34;&gt;llvmlite&lt;/a&gt; 是由 Numba 的开发团队创建的，已经成为了当下在 Python 中做 LLVM 开发的有力竞争者。它基于 Numba 项目的需求，只实现了一小部分 LLVM 的功能。但是这个功能子集已经能够满足大部分 LLVM 开发者使用了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/revng/llvmcpy&#34;&gt;llvmcpy&lt;/a&gt; 旨在更新 Python 为 C 库提供的绑定，使得它们能够以自动化的形式保持更新，并且 Python 的原生语法使得它们能够很方便的使用。llvmcpy 依然处于初级阶段，但是已经做了很多和 LLVM API 打交道的基础工作。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’re curious about how to use LLVM libraries to build a language, LLVM’s own creators have a tutorial, using either C++ or OCAML, that steps you through creating a simple language called Kaleidoscope. It’s since been ported to other languages:&lt;/p&gt;

&lt;p&gt;如果你很好奇如何使用 LLVM 库构建一门语言的话，LLVM 的原创者们提供了&lt;a href=&#34;https://llvm.org/docs/tutorial/index.html&#34;&gt;教程&lt;/a&gt;，该教程使用 C++ 或者 OCAML ，指导你从头到尾创造一门简单的语言 &lt;strong&gt;Kaleidoscope&lt;/strong&gt;，而这个示例已经被移植到其他语言上了：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.stephendiehl.com/llvm/&#34;&gt;Haskell&lt;/a&gt;: 和原始教程最接近的移植；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Python：&lt;a href=&#34;https://github.com/eliben/pykaleidoscope&#34;&gt;一个版本&lt;/a&gt;和该教程非常接近，&lt;a href=&#34;https://github.com/frederickjeanguerin/pykaleidoscope&#34;&gt;另外一个版本&lt;/a&gt; 更激进一些，重写了一个交互命令行。两者都使用了 llvmlite 作为和 LLVM 的绑定；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/jauhien/iron-kaleidoscope&#34;&gt;Rust&lt;/a&gt; 和 &lt;a href=&#34;https://harlanhaskins.com/2017/01/08/building-a-compiler-with-swift-in-llvm-part-1-introduction-and-the-lexer.html&#34;&gt;Swift&lt;/a&gt;：似乎不可避免，我们会得到这两个语言版本的移植版本教程，因为 LLVM 本身更就是因为这二者才得以创造的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，这个教程也有其他人类语言的版本。它已经被翻译成中文了，有使用 &lt;a href=&#34;https://github.com/liancheng/llvm-tutorial-cn&#34;&gt;C++&lt;/a&gt; 的，也有 &lt;a href=&#34;https://github.com/moevis/Kaleidoscope-LLVM-tutorial-zh-cn&#34;&gt;Python&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;llvm-做不到哪些&#34;&gt;LLVM 做不到哪些&lt;/h2&gt;

&lt;p&gt;以上提到的都是 LLVM 能够提供的功能，它还有一些无法做到的事情，了解一下会比较有用。&lt;/p&gt;

&lt;p&gt;举例而言，LLVM 不会进行语法解析。许多工具，比如 &lt;a href=&#34;http://dinosaur.compilertools.net/&#34;&gt;lex/yacc&lt;/a&gt;，&lt;a href=&#34;http://aquamentus.com/flex_bison.html&#34;&gt;ﬂex/bison&lt;/a&gt; 以及 &lt;a href=&#34;http://www.antlr.org/&#34;&gt;ANTLR&lt;/a&gt; 等都已经做了这些工作。解析语法就意味着要和编译行为进行解耦，所以，LLVM 没有试图去做这部分工作也不意外。&lt;/p&gt;

&lt;p&gt;LLVM 也不会试图解决围绕某种特定语言更大范围的周边行为。你需要自行安装编译器二进制，管理安装过程中的包以及升级工具链。&lt;/p&gt;

&lt;p&gt;最后一点，也是最重要的是，依然又很多语言通用的部分 LLVM 没有原生支持的。许多编程语言都存在垃圾回收内存管理的行为，要么作为管理内存的主要方式，要么作为某种策略，例如 RAII（C++ 和 Rust 语言中使用的）的辅助。LLVM 不提供垃圾回收机制，但是它确实&lt;a href=&#34;https://llvm.org/docs/GarbageCollection.html&#34;&gt;提供一些工具&lt;/a&gt;，能够允许代码可以使用元数据来做标记使得编写垃圾收集器更加容易。&lt;/p&gt;

&lt;p&gt;尽管如此，LLVM 还是存在最终添加原生支持执行垃圾回收机制的可能性。LLVM 正在以每 6 个月一个大版本更新在快速发展。而这个发展步速很大程度上因为目前很多主流编程语言已经把其作为它们开发过程的核心一环。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>In App Purchase</title>
      <link>https://hechen.xyz/post/in-app-purchase/</link>
      <pubDate>Thu, 24 May 2018 10:40:39 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/in-app-purchase/</guid>
      
        <description>

&lt;p&gt;对于在 App Store 中上架的应⽤来说，应⽤内购买(In-App Purchase，简称 IAP) 应该是一个避不开的话题，尤其是去年微信打赏和 Apple 之间的争执更让 IAP 火了一把，不仅仅大公司，作为个人开发者来讲，IAP 也是非常重要的，说不定就是你养家糊口的工具呢。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;整个 IAP 的过程，在客户端的实现依赖于 &lt;code&gt;StoreKit&lt;/code&gt; 这个框架，所有的支付相关操作都是交由 StoreKit 来完成的。&lt;/p&gt;

&lt;p&gt;首先，我们先复习一下 IAP 的整个流程。&lt;/p&gt;

&lt;h2 id=&#34;in-app-purchase-的整体流程&#34;&gt;In App Purchase 的整体流程&lt;/h2&gt;

&lt;h3 id=&#34;阶段-1&#34;&gt;阶段 1&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-4DDE8387-EDB1-42CC-B18C-3DC6CA1DC688.png&#34; alt=&#34;In App Purchase 过程&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;加载 In-App Identifier&lt;/li&gt;
&lt;li&gt;客户端从 AppStore 中获取本地化的商品信息。&lt;/li&gt;
&lt;li&gt;把 IAP 的购买界⾯面展示给⽤用户，⽤用户可以同意购买并点击购买按钮。&lt;/li&gt;
&lt;li&gt;⽤用户授权购买，客户端向服务器器发送购买请求。&lt;/li&gt;
&lt;li&gt;服务器器处理理购买请求，并把结果返回给 StoreKit。&lt;/li&gt;
&lt;li&gt;如果购买请求验证通过，客户端此时解锁内容或者提供⾦金金币。&lt;/li&gt;
&lt;li&gt;至此，整个交易易流程结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;阶段-2&#34;&gt;阶段 2&lt;/h3&gt;

&lt;p&gt;具体到和 Apple Store 打交道的话，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-08-27-intro_2x.png&#34; alt=&#34;IAP With App Store&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;阶段-3&#34;&gt;阶段 3&lt;/h3&gt;

&lt;p&gt;如果涉及到自己 App 端 Server 的参与，基本如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-08-29-1*MwLeHUGSupbb9j-oYQyflw.png&#34; alt=&#34;IAP With Business Server&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正常多出的几步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;获取 Product 标识列表；&lt;/li&gt;
&lt;li&gt;客户端上传 Receipt 数据给 Server，Server 自行校验或者使用 Apple 的接口校验；&lt;/li&gt;
&lt;li&gt;Server 端告知给客户端付费内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;注册商品&#34;&gt;注册商品&lt;/h3&gt;

&lt;p&gt;商品注册是通过 iTunes Connect 后台进行的，其中商品类型需要提前明确好。&lt;/p&gt;

&lt;h4 id=&#34;商品类型&#34;&gt;商品类型&lt;/h4&gt;

&lt;p&gt;参与 App 内支付动作的商品有四种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Consumable products （消耗型商品）&lt;/li&gt;
&lt;li&gt;Non-consumable products （非消耗型商品）&lt;/li&gt;
&lt;li&gt;Auto-renewable subscriptions （自动续约订阅）&lt;/li&gt;
&lt;li&gt;Non-renewable subscriptions （非自动续约订阅）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中关于非自动续约订阅，App 的开发者有义务同步服务到用户的所有设备上。&lt;/p&gt;

&lt;p&gt;如下，是官方文档列出来的四种商品类型的一些主要属性。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Product type&lt;/th&gt;
&lt;th&gt;Non-consumable&lt;/th&gt;
&lt;th&gt;Consumable&lt;/th&gt;
&lt;th&gt;Auto-renewable&lt;/th&gt;
&lt;th&gt;Non-renewing&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Users can buy&lt;/td&gt;
&lt;td&gt;Once&lt;/td&gt;
&lt;td&gt;Multiple times&lt;/td&gt;
&lt;td&gt;Multiple times&lt;/td&gt;
&lt;td&gt;Multiple times&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Appears in the receipt&lt;/td&gt;
&lt;td&gt;Always&lt;/td&gt;
&lt;td&gt;Once&lt;/td&gt;
&lt;td&gt;Always&lt;/td&gt;
&lt;td&gt;Always&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Synced across devices&lt;/td&gt;
&lt;td&gt;By the system&lt;/td&gt;
&lt;td&gt;Not synced&lt;/td&gt;
&lt;td&gt;By the system&lt;/td&gt;
&lt;td&gt;By your app&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Restored&lt;/td&gt;
&lt;td&gt;By the system&lt;/td&gt;
&lt;td&gt;Not restored&lt;/td&gt;
&lt;td&gt;By the system&lt;/td&gt;
&lt;td&gt;By your app&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中需要注意的几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除了非消耗型商品只能买一次，再次购买应该会失败以外，其他三种类型（消耗型，连续/非连续订阅）都是可以无限制购买的，Apple 是不会报错的；&lt;/li&gt;
&lt;li&gt;除了消耗型商品在 Receipt 中出现一次，其他三种类型（非消耗型，连续/非连续订阅）是始终都会在其中的，这也是后续做订阅校验至关重要的一环；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;获取-product-id&#34;&gt;获取 Product ID&lt;/h3&gt;

&lt;p&gt;这里获取的是 Product 在 iTunes Connect 后台注册商品时填写的 Product ID&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-15359854946888.png&#34; alt=&#34;Product ID&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In-App Identifier 为每个可销售的商品提供一个唯一标识。在客户端上，我们可以直接写死代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let identifiers = [&amp;quot;com.myCompany.myApp.product1&amp;quot;, &amp;quot;com.myCompany.myApp.product2&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者从 Server 端获取。&lt;/p&gt;

&lt;h3 id=&#34;获取商品信息&#34;&gt;获取商品信息&lt;/h3&gt;

&lt;p&gt;然后通过上一步取得的 Product ID 来获取具体某个 Product 的详细信息，包括价格，描述等等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// 获取一批商品的信息

let request = SKProductsRequest(productIdentifiers: identifierSet) 

request.delegate = self

request.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代理回调中处理获取的结果，进行展示或者 Cache。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func productRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) {

    for product in response.products {
    
    } 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;官方建议是不要进行缓存，因为 Product 的信息有可能会更新，比如用户切换 AppStore 的区域，价格信息也会因为相应的汇率发生变化。不过！在国内，被牺牲最大的用户体验不是这种边界情况，而是获取 Product 信息是需要和 Apple Server 打交道的，这就有个问题 —— 慢！&lt;/p&gt;

&lt;p&gt;我们会在开机的时候提前预取所有 Product 信息，并且缓存起来。下次弹出充值面板的时候就直接列出商品信息即可。&lt;/p&gt;

&lt;h2 id=&#34;展示支付-ui&#34;&gt;展示支付 UI&lt;/h2&gt;

&lt;p&gt;接下来就看什么时候进行购买了，展示商品面板进行购买。用户在面板上进行选择之后，就进入了下一阶段 ── 支付&lt;/p&gt;

&lt;h2 id=&#34;发出购买请求&#34;&gt;发出购买请求&lt;/h2&gt;

&lt;p&gt;这⼀步也很简单， 两⾏行代码就可以搞定。只需要把之前拿到的商品对象传到 &lt;code&gt;SKPayment&lt;/code&gt; 的初始化方法中，构造一个 &lt;code&gt;SKPayment&lt;/code&gt; 实例，再把这个实例加⼊到购买队列中即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let payment = SKPayment(product: product) SKPaymentQueue.default().add(payment)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后就交给 Apple 了，此时应用内会弹出苹果设计的购买窗口，用户只要使⽤指纹或者输入密码即可同意付款。&lt;/p&gt;

&lt;h2 id=&#34;处理购买结果&#34;&gt;处理购买结果&lt;/h2&gt;

&lt;p&gt;当⽤户的购买请求经过 &lt;code&gt;StoreKit&lt;/code&gt; 和苹果服务器的验证后，开发者可以在回调函数中接收到。Apple 具体的回调会通过 &lt;code&gt;SKPaymentQueue&lt;/code&gt; 来进行，如下，我们需要在支付之前就向 &lt;code&gt;SKPaymentQueue&lt;/code&gt; 中加入代理监听。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;SKPaymentQueue.default().add(self)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以把具体的监听放在一个独立的类中完成。在该 Observer 中，实现代理方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// 处理理 SKPaymentQueueObserver 事件
// MARK: - SKPaymentTransactionObserver
func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions:[SK PaymentTransaction]) {
    for transaction in transactions {
        switch transaction.transactionState { 
            case .purchased:
            // Validate the purchase
            
            // Locate the file
            guard let url = Bundle.main.appStoreReceiptURL else {
                // Handle failure
                return    
            }

            // Read the contents
            let receipt = Data(contentsOf: url)
        } 
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于每一个你提交的 Payment，就一定会有一个相应的 Transaction 生成以便其后续处理。通过检查 transaction 的状态，我们可以指定每种状态下的处理逻辑。如果状态显示已购买， 我们还是应该和⾃己的服务器器进行一次校验，确保交易真实有效⽽而不是通过越狱后的某些插件完成的。被检验的，是一种被苹果称之为收据(receipt)的凭证，就像我们在超市购物或者饭店就餐后拿到的收据一样，每⼀个购买的商品都有⾃己的收据。这个收据由苹果签发，保存在客户端本地。&lt;/p&gt;

&lt;p&gt;目前 Apple 官方提供两种方式，一种是本机校验，一种是 Server 端校验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-E9DC4D03-7F18-49CC-B21D-835904E2B39F.png&#34; alt=&#34;Receipt Validation Ways&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;final-投递商品&#34;&gt;Final，投递商品&lt;/h2&gt;

&lt;p&gt;当 Server 端检验完成之后，说明本地交易已经成功完成，因此将用户购买的内容提供给用户使用。当然，对于业务方，购买完成不代表业务完成，因此大多数情况下还有一步进行商品业务校验的过程。&lt;/p&gt;

&lt;p&gt;需要注意的一点是：&lt;/p&gt;

&lt;p&gt;Apple 也明确告诉开发者有几个关键的路径节点需要注意：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/2018-09-03-C1BB8495-728D-43E7-9C40-8EC9B3A22905.png&#34; alt=&#34;关键路径&#34; /&gt;&lt;/p&gt;

&lt;p&gt;监听交易状态的代码一定要越早越好，比如在 App 完成启动之后进行注册，确保整个生命周期内都有代码逻辑来处理监听到的交易，根据监听到的 Transaction 的状态来分发处理逻辑。因为很有可能你监听的时机太晚，导致 Apple 通知有一些之前未完成的交易的时候你无法捕获。说白了就是用户的购买流程跟 App 生命周期不挂钩导致的，典型的有以下几个场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用户杀死了 App&lt;/li&gt;
&lt;li&gt;用户需要更新帐号中的付费信息（此时已跳出 App ）&lt;/li&gt;
&lt;li&gt;App 闪退&lt;/li&gt;
&lt;li&gt;用户进行了订阅续期&lt;/li&gt;
&lt;li&gt;用户进入了推介促销价的流程&lt;/li&gt;
&lt;li&gt;用户跳出 App 输入推广码&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;结束交易&#34;&gt;结束交易&lt;/h2&gt;

&lt;p&gt;在最后一步中，如果是正常的交易，那么简单的结束它们就⾏了。但对于其他异常的交易易，⽐比如出现了一些 error，也要妥善的结束它们。如果是⾃动续期的订阅，也会经过这一步。如果 交易没有被正确的结束，它们会一直停留留在上文提到的队列中，每次回调函数被调用时，队列 中都会有这些没有被结束的交易。也就是为什么需要提前监听的原因了。&lt;/p&gt;

&lt;p&gt;结束交易的代码⾮常简单，只有一行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;SKPaymentQueue.default().finishTransaction(transaction)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关于-transaction-和-receipt-的区别和联系&#34;&gt;关于 Transaction 和 Receipt 的区别和联系&lt;/h3&gt;

&lt;p&gt;很多同学在进行 IAP 开发的时候常常有一个很大的困惑就是 Transaction 和 Receipt 傻傻分不清楚，这里重新梳理了一下。&lt;/p&gt;

&lt;h4 id=&#34;关于-transaction&#34;&gt;关于 Transaction&lt;/h4&gt;

&lt;p&gt;其实前面讲 Payment 的操作的时候已经表明了， Transaction 是和具体的一次 Payment 对应的，也就是发生一次 Payment 就会生成 Transaction，但是，并不是 1 对 1 的关系，比如本次 Payment 对应的 Transaction 已经被 finish 了，用户换了手机，登陆同样 AppleID 的时候使用 Restore 功能，Apple 会生成 Transaction 给你，本次的 Transaction 就对应的之前的 Payment，只是状态标记为 .restored。&lt;/p&gt;

&lt;p&gt;Transaction 的状态主要有以下这么几种：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;状态&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;.purchasing&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不需要做什么，继续等待 SKPaymentTransactionState 的状态流转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;.purchased&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用户已完成付费，处理付费后的流程并调用 finishTransaction 方法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;.failed&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用户付费失败，处理付费失败的流程并调用 finishTransaction 方法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;.restored&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;用户付费成功，处理付费后的流程并调用 finishTransaction 方法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;.deferred&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不需要做什么，继续等待 SKPaymentTransactionState 的状态流转&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: 对于 &lt;code&gt;finishTransaction&lt;/code&gt; 的几点说明：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于那些依赖苹果下载服务的，比如存储在 iTunes Connect 上的付费内容要下载到本地，如果下载完成之前就进行了 finish 动作会导致 Apple 阻断所有的下载流程，并且无法重新下载；&lt;/li&gt;
&lt;li&gt;Transaction 需要配合 Receipt 验证是否合法，单纯靠前端是不靠谱的，因此交由业务后端验证 Receipt 更安全合理，业务后端来决定是否需要 finish&lt;/li&gt;
&lt;li&gt;文档里说：Your app needs to finish every transaction, regardless of whether the transaction succeeded or failed. 所以我们需要将 Transaction Finish 掉，否则会始终出现在 PaymentQueue 里，BUT，中间态的交易是不需要 finish 的，比如 .purchasing 和 .deferred&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;关于-receipt&#34;&gt;关于 Receipt&lt;/h4&gt;

&lt;p&gt;Receipt 是 App Store 签发的，是你的 App 上和该 App 上发生的支付行为记录。它存储在设备上的某个固定地址，StoreKit 并不会生成它，它是从 App Store 拉取下来的一个文件。如图所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
guard let url = Bundle.main.appStoreReceiptURL else {
    // handle failure
    return
}

// read the contents
let receipt = Data(contentsOf: url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果本地该地址里没有，我们还可以进行刷新，实质上就是从 App Store 请求 Receipt 数据。请求如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let request = SKReceiptRefreshRequest()

request.delegate = self

request.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;这里有几个需要注意的点&#34;&gt;这里有几个需要注意的点：&lt;/h2&gt;

&lt;h3 id=&#34;恢复已经购买的商品&#34;&gt;恢复已经购买的商品&lt;/h3&gt;

&lt;p&gt;这里有一个需要注意的事情就是：如果一个用户试图去购买一个之前购买过的商品，而不是使用你App 提供的 Restore 功能恢复的话，App Store 会依然创建一个正常的新交易。用户是不会被再次收费的，这里的问题是，Transaction 的状态可不是 restored，而是完全新的 Transaction，你可以按照之前的正常流程走，当然对于自带账户体系的 App 来讲，需要自行判断和计算。&lt;/p&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料：&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/in-app-purchase/&#34;&gt;In App Purchase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Introduction.html&#34;&gt;In-App Purchase Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html&#34;&gt;Receipt Validation Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://forums.developer.apple.com/thread/46737&#34;&gt;How to detect refunded IAPs from receipts?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/10771240/check-if-a-non-renewable-subscription-was-refunded-by-apple&#34;&gt;Check if a non-renewable subscription was refunded by Apple?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6439482/how-does-apple-notify-ios-apps-of-refunds-of-in-app-purchases-iap&#34;&gt;How does Apple notify iOS apps of refunds of in-app purchases (IAP)?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>在 Swift 中使用工厂模式进行依赖注入</title>
      <link>https://hechen.xyz/post/dependency-injection-using-factories-in-swift/</link>
      <pubDate>Sun, 19 Nov 2017 18:17:15 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/dependency-injection-using-factories-in-swift/</guid>
      
        <description>

&lt;p&gt;依赖注入是一项使得代码更加可测试的关键工具。我们不需要持有某些对象，或者创建这些对象的自有依赖，或者通过单例来获取他们，而是尽可能使那些对象能够正常运转所必须的一切内容（其他对象）通过外界传入，这样做的好处在于，一方面能清晰的看得到某个对象的所有依赖项，另一方便也使得测试工作变得更为简单（因为我们可以模拟这些依赖项来捕获、验证状态以及值。）&lt;/p&gt;

&lt;p&gt;然而，尽管依赖注入确实很有用，但是当在工程中广泛使用的时候还是会有一些痛点。随着某个对象的依赖项越来越多，初始化该对象就变得越来越蹩脚。虽然使得代码可测没毛病，但是如果像下面这种每次需要这样来写初始化方法，也太不爽了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UserManager {
    init(dataLoader: DataLoader, database: Database, cache: Cache,
        keychain: Keychain, tokenManager: TokenManager) {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，这周咱们来深入了解一下某种依赖注入的技巧，使得我们的代码不失去可测性，我们也不需要再强迫自己去写一团初始化方法或者复杂的依赖管理的代码。&lt;/p&gt;

&lt;h2 id=&#34;传递依赖项&#34;&gt;传递依赖项&lt;/h2&gt;

&lt;p&gt;我们遇到上面代码 demo 中的问题，最主要的原因是我们需要把这么多依赖项传递给某个对象，以便之后来使用。举例来说，我们在构建一个消息收发的 App，这里有一个 view controller 需要展示某个用户所有的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MessageListViewController: UITableViewController {
    private let loader: MessageLoader

    init(loader: MessageLoader) {
        self.loader = loader
        super.init(nibName: nil, bundle: nil)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        loader.load { [weak self]() messages in
            self?.reloadTableView(with: messages)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码能看到，我们给 &lt;code&gt;MessageListViewController&lt;/code&gt; 传入某个依赖项 &lt;code&gt;MessageLoader&lt;/code&gt;，之后其被用来加载数据。这里其实并没有太大的问题，因为仅仅只有一个依赖而已。然而，我们的列表视图并不是一个死气沉沉的展示而已，某些状态下还需要们进行导航到某视图控制器的工作。&lt;/p&gt;

&lt;p&gt;具体来讲，我们想让用户在点击消息列表中某个 cell 的时候，导航到一个新的视图中。我们为这个新的视图创建一个视图控制器 &lt;code&gt;MessageViewController&lt;/code&gt;，使得用户能够单独查看某条消息，并且能够回复该消息。为了该功能，我们实现了 &lt;code&gt;MessageSender&lt;/code&gt; 类，当创建该类的时候，我们将前面那个新的视图控制器传递给他，代码类似下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    let message = messages[indexPath.row]()
    let viewController = MessageViewController(message: message, sender: sender)
    navigationController?.pushViewController(viewController, animated: true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题来了，&lt;code&gt;MessageViewController&lt;/code&gt; 需要有一个 &lt;code&gt;MessageSender&lt;/code&gt; 实例，我们也需要使得 &lt;code&gt;MessageListViewController&lt;/code&gt; 看到该类。一种办法就是简单的，将 sender 加入到 列表视图控制器的初始化方法中，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MessageListViewController: UITableViewController {
    init(loader: MessageLoader, sender: MessageSender) {
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦如上面这样开始写代码，我们就逐步的进入庞大初始化方法的不归路上咯，然后使得 &lt;code&gt;MessageListViewController&lt;/code&gt; 会变得越来越难用（也会让调用这很困惑，为什么一个列表视图控制器还需要关心某个发送消息的人？）。&lt;/p&gt;

&lt;p&gt;另外一个可能的解决方案（也是一个很常用的解决方案），就是把 MessageSender 做成一个单例，这样的话，我们可以很容易在任何地方取到他的值，也可以随时将单例对象注入&lt;code&gt;MessageViewController&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let viewController = MessageViewController(
    message: message,
    sender: MessageSender.shared
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，就如 &lt;a href=&#34;https://www.swiftbysundell.com/posts/avoiding-singletons-in-swift&#34;&gt;Avoiding singletons in Swift&lt;/a&gt; 这篇文章中讲的，单例这种方式会伴随一些明显的缺陷，导致我们会难以看清依赖关系，从而对整个框架都难以理解。&lt;/p&gt;

&lt;h2 id=&#34;工厂模式来救场&#34;&gt;工厂模式来救场&lt;/h2&gt;

&lt;p&gt;Wouldn&amp;rsquo;t it be nice if we could just skip all of the above, and enable MessageListViewController to be completely unaware of MessageSender, and all other dependencies that any subsequent view controllers might need?&lt;/p&gt;

&lt;p&gt;如果我们能够避免掉上面这些问题，能够使得 &lt;code&gt;MessageListViewController&lt;/code&gt; 完全不关心 &lt;code&gt;MessageSender&lt;/code&gt;，甚至是后续的视图控制器的其他依赖，岂不是很爽？&lt;/p&gt;

&lt;p&gt;如果我们有某种形式的工厂，我们可以给其传入指定的 message，然后很方便的产出一个 &lt;code&gt;MessageViewController&lt;/code&gt; 出来，类似下面这样，就能够很方便并且简洁的实现上面的理想：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let viewController = factory.makeMessageViewController(for: message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如 &lt;a href=&#34;https://www.swiftbysundell.com/posts/using-the-factory-pattern-to-avoid-shared-state-in-swift?rq=factories&#34;&gt;Using the factory pattern to avoid shared state in Swift&lt;/a&gt; 这篇文章中我们看到的，关于工厂模式中，我最喜欢的一点就是，他能够使得你将某个对象的创建和使用两者解耦，也能使得许多对象和这些对象的依赖之间有一个相对解耦的关系，进而能使得我们想重构代码或者修改某些部分的时候相对更容易一些。&lt;/p&gt;

&lt;h3 id=&#34;那我们该怎么做呢&#34;&gt;那我们该怎么做呢？&lt;/h3&gt;

&lt;p&gt;首先，我们定义一个工厂协议，该协议使得我们能够在并不知道某个视图控制器的依赖项或者其初始化方法的前提下，很容易的在我们的应用中创建出我们需要的任意的视图控制器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol ViewControllerFactory {
    func makeMessageListViewController() -&amp;gt; MessageListViewController
    func makeMessageViewController(for message: Message) -&amp;gt; MessageViewController
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里我们还不能停止。我们同样为工厂添加一些附件的协议用来创建视图控制器的依赖，比如下面这个协议，使得我们可以为某个列表视图控制器生成一个 &lt;code&gt;MessageLoader&lt;/code&gt; 出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol MessageLoaderFactory {
    func makeMessageLoader() -&amp;gt; MessageLoader
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;单例依赖&#34;&gt;单例依赖&lt;/h2&gt;

&lt;p&gt;一旦我们准备好这些工厂协议之后，回到上面 &lt;code&gt;MessageListViewController&lt;/code&gt; 的地方，重构这段代码，无需使用其依赖项的实例而是简单的引入一个工厂实例即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MessageListViewController: UITableViewController {
    
    
    typealias Factory = MessageLoaderFactory &amp;amp; ViewControllerFactory

    private let factory: Factory
    
    private lazy var loader = factory.makeMessageLoader()

    init(factory: Factory) {
        self.factory = factory
        super.init(nibName: nil, bundle: nil)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面这么做，我们可以做到两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我们将一堆依赖项简化成了一个单一的工厂；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MessageListViewController&lt;/code&gt; 无需再需再关心 &lt;code&gt;MessageViewController&lt;/code&gt; 的依赖项了&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;一个使用-container-的例子&#34;&gt;一个使用 Container 的例子&lt;/h2&gt;

&lt;p&gt;接下来，我们该实现工厂协议了。首先，我们需要定义一个 &lt;code&gt;DependencyContainer&lt;/code&gt;，该对象会包含我们应用中那些正常情况下会被直接用来作为依赖的核心工具对象们。这些不仅仅包括类似之前 &lt;code&gt;MessageSender&lt;/code&gt;，也包括更加底层的业务逻辑上的类，比如我们可能会用到 &lt;code&gt;NetworkManager&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DependencyContainer {
    private lazy var messageSender = MessageSender(networkManager: networkManager)
    private lazy var networkManager = NetworkManager(urlSession: .shared)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面这段代码，你能看到，我们使用了懒加载属性以便能够在初始化该对象的时候能够引用相同类中的其他属性。这是设置你依赖关系的一种非常方便而且优雅的方式，你可以利用编译器帮助你避免比如&lt;a href=&#34;https://en.wikipedia.org/wiki/Circular_dependency&#34;&gt;引用循环&lt;/a&gt;等问题。&lt;/p&gt;

&lt;p&gt;最后，我们为 &lt;code&gt;DependencyContainer&lt;/code&gt; 实现我们的工厂协议，使得我们能够将该工厂注入各种视图控制器或其他对象中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension DependencyContainer: ViewControllerFactory {
    func makeMessageListViewController() -&amp;gt; MessageListViewController {
        return MessageListViewController(factory: self)
    }

    func makeMessageViewController(for message: Message) -&amp;gt; MessageViewController {
        return MessageViewController(message: message, sender: messageSender)
    }
}

extension DependencyContainer: MessageLoaderFactory {
    func makeMessageLoader() -&amp;gt; MessageLoader {
        return MessageLoader(networkManager: networkManager)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分布式的所有权&#34;&gt;分布式的所有权&lt;/h2&gt;

&lt;p&gt;最后一步了，我们在哪里实际储存依赖存储器，谁应该拥有它？它应该在哪里设置？这里有些比较 cool 的事情就是，由于我们把依赖容器作为对象们所需要的工厂的一种实现，而对象们强持有其工厂，所以，我们其实无需在任何地方储存该依赖容器。&lt;/p&gt;

&lt;p&gt;举例来说，如果 &lt;code&gt;MessageListViewController&lt;/code&gt; 是我们应用的初始化视图控制器，我们可以很简单的创建一个 &lt;code&gt;DependencyContainer&lt;/code&gt; 的实例传入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let container = DependencyContainer()
let listViewController = container.makeMessageListViewController()

window.rootViewController = UINavigationController(
    rootViewController: listViewController
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无需保留任何全局的变量或者在 app delegate 中使用可选属性。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;使用工厂协议和容器配置依赖注入是一种很好的方式，其可以避免需要传递大量依赖而创建很复杂的初始化方法。它可以使得依赖注入使用起来更加方便，使得你能够对自己创建的对象实际的依赖关系有很明晰的判断，也使得测试更加简单。&lt;/p&gt;

&lt;p&gt;因为我们能够把工厂定义为协议，因此可以很容易的在测试中通过给定不同测试指定版本的具体实现来模拟输出。未来我会写大量关于模拟数据以及如何在测试中充分利用依赖注入的博文。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>模块化 Xcode 工程</title>
      <link>https://hechen.xyz/post/modular-xcode-projects/</link>
      <pubDate>Sun, 19 Nov 2017 18:17:15 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/modular-xcode-projects/</guid>
      
        <description>

&lt;p&gt;使用 Xcode 构建模块化的工程就需要对工程结构以及其基础概念有很好的理解才行。&lt;!-- more --&gt; 我们平时不怎么关注工程结构本身，只有在工程逐渐变大，要添加更多依赖的时候才会注意的到。而即使到了这个时候，我们大多数的工程都会使用  &lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; 来设置那些依赖项，或者 &lt;a href=&#34;https://github.com/carthage&#34;&gt;Carthage&lt;/a&gt;, 后者虽然没有帮我们做依赖性的设置，但是使得我们会更容易的，通过在工程的 build phase 选项中添加一些内容，达到同样的目的。当配置项越来越复杂，我们就很容易产生困惑，这是因为我们并没有完全掌握 Xcode 工程中所涉及的所有元素。我经常被问到的问题如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我能不能在工程里同时使用 Carthage，Cocoapods 以及自己个人的依赖设置？&lt;/li&gt;
&lt;li&gt;我添加了依赖，但是当模拟器打开 App 的时候 Crash 了。&lt;/li&gt;
&lt;li&gt;为什么我需要只在某些 targets 里嵌入 framework？&lt;/li&gt;
&lt;li&gt;我的 framework 应该是静态的还是动态的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这篇博文中，我会引导你遍历 Xcode Project 中的各个元素，指导你如何通过改变这些元素来模块化你的设置项。我希望下次你遇到上面这些问题的时候，你不需要再花大量时间取 Stack Overflow 上查这些确定的答案。&lt;/p&gt;

&lt;h3 id=&#34;elements&#34;&gt;Elements ⚒&lt;/h3&gt;

&lt;h4 id=&#34;target&#34;&gt;Target&lt;/h4&gt;

&lt;p&gt;工程（Projects）都是由多个更小的叫做 target 的单元组成的。这些 target 包含编译特定平台产品，比如 frameworks, libraries, apps, testing bundles, extensions 等所需要的配置。 你可以在&lt;a href=&#34;https://github.com/xcodeswift/xcproj/blob/master/Sources/xcproj/PBXProductType.swift&#34;&gt;这里&lt;/a&gt;看到 target 所有可用的类型。 Target 可以相互依赖，当一个 target A 依赖另外一个 target B 的时候，target B 就会被先构建出来以便 target A 使用其产出。而 target 的配置项会涉及以下几个地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Info.plist 文件&lt;/strong&gt;: 该文件包含产出特定的设置项，比如 版本、App 的名字或者 App 的类型，你可以在&lt;a href=&#34;https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html&#34;&gt;这里&lt;/a&gt;详细了解这个文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entitlements&lt;/strong&gt;: 其指定了应用的能力。如果在授权文件中指定的能力和开发者平台上设置的无法匹配，签名过程就会出错。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build settings&lt;/strong&gt;: 如其名字所描述的那样，这些都是构建 target 所必要的设置项。构建设置项要么在 target 自身定义或者在 &lt;code&gt;xcconfig&lt;/code&gt; 文件中定义。一个 target 的配置项可以继承而来，首先是配置文件本身，其次是 target 的配置项，最后是 project 配置项。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build phases&lt;/strong&gt;: 构建流水线由 build phase 定义。当一个 target 被创建出来之后，其包含默认的构建阶段（包含 *构建源码、拷贝资源等*），但是你可以自行添加你需要的。举个例子，这些阶段里，有个 shell script phase 允许你在构建过程中执行一些脚本。这些脚本可以读取 Xcode 暴露出来的那些&lt;a href=&#34;http://ppinera.es/2017/09/15/modular-xcode-projects.html&#34;&gt;构建参数&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于&lt;code&gt;.xcconfig&lt;/code&gt;文件的可组合性以及其可重用性的考虑，强烈建议你在这些文件中定义你那些编译设置。Target 的配置，比如 build setting 、build phase 等的变更都体现在 &lt;code&gt;.pbxproj&lt;/code&gt; 文件中，这个文件是一种特殊的plist 文件，当我们使用 Git 管理我们的工程的时候，这个文件很容易出现冲突。当然，更新 &lt;code&gt;pbxproj&lt;/code&gt; 文件中配置的最简单方式就是使用 Xcode，其了解如何从这些文件中读取配置和向其中写入配置。如果你对不使用 Xcode 更新 &lt;code&gt;pbxproj&lt;/code&gt; 文件感兴趣的话，你可以试试 &lt;a href=&#34;https://github.com/cocoapods/xcodeproj&#34;&gt;Xcodeproj&lt;/a&gt; 或者 &lt;a href=&#34;https://github.com/swift-xcode/xcodeproj&#34;&gt;xcproj&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;构建这些 target 的输出要么是比如 app，extension 或者测试文件等 &lt;strong&gt;bundles&lt;/strong&gt;，要么就是&lt;strong&gt;intermediate products&lt;/strong&gt; ，例如 library 或者那些封装了代码和资源文件用来给别的 target 使用的 framework。这些 Target 的输出内容你可以在工程文件中的 &lt;code&gt;Products&lt;/code&gt; 的 Group 下找到，如果有红色的文件引用表示没有 product 输出，很大可能是你还没有构建过这个 target。&lt;/p&gt;

&lt;h4 id=&#34;scheme&#34;&gt;Scheme&lt;/h4&gt;

&lt;p&gt;Xcode 工程中另外一个要素是 scheme。 一个工程可以包含多个 scheme，他们可以被共享，作为工程的一部分被人们使用。这些 scheme 指定了 Xcode 中每个具体动作的配置，这些动作包括：&lt;strong&gt;run&lt;/strong&gt;，&lt;strong&gt;test&lt;/strong&gt;，&lt;strong&gt;profile&lt;/strong&gt;，&lt;strong&gt;analyze&lt;/strong&gt; 以及 &lt;strong&gt;archive&lt;/strong&gt;。 细的来讲，可以指定哪些 target 需要被构建，以什么顺序构建甚至针对每一种动作指定不同的配置。&lt;/p&gt;

&lt;p&gt;关于 scheme 的编译配置有一些东西要讲。当我们指定针对哪些动作构建哪些 target 的时候，在下面两种情况下，我们不需要指定每个 target 的依赖项：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果依赖项是是相同 project 中的一部分，并且已经在 &lt;code&gt;Target dependencies&lt;/code&gt; 的 &lt;code&gt;Build Phases&lt;/code&gt; 中定义过；&lt;/li&gt;
&lt;li&gt;开启了 &lt;code&gt;Find implicit dependencies&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第 2 点中开启的标识，构建过程必须找到 target 的依赖项，并且先行构建。另外，如果你开启了&lt;code&gt;Parallelize build&lt;/code&gt; 的话，一旦 target 相互之间没有依赖的话，就能够并行构建，因而会节省一部分时间。&lt;/p&gt;

&lt;p&gt;一个有问题的构建配置会导致你编译 target 的时候出现错误，比如 &lt;code&gt;Framework XXX not found&lt;/code&gt;。如果你曾经或者当前遇到了类似的报错，检查一下在构建每个 scheme 的时候，你的 target 的所有依赖是否已经被构建。&lt;/p&gt;

&lt;p&gt;scheme 文件定义是存储在 &lt;code&gt;Project.xcodeproj/xcshareddata/xcodeproj.xcscheme&lt;/code&gt; 路径下的一个标准的 XML 文本，因此你可以很容易的使用任意 XML 编辑器来修改它。&lt;/p&gt;

&lt;h4 id=&#34;workspace&#34;&gt;Workspace&lt;/h4&gt;

&lt;p&gt;多个 project 文件被组合成一个 workspace。当 project 被添加到一个 workspace 的时候：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;其 schemes 会出现在 workspace 的 scheme 列表中；&lt;/li&gt;
&lt;li&gt;project 彼此可以产生依赖关系，后文会讲到。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和 scheme 类似，workspace 也是普通的 XML 文件，修改起来很方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/wGXI5fy.png&#34; alt=&#34;工程构建组合中的每一个基础元素： target、scheme、project 以及 workspace 是如何被组织起来的&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;dependencies&#34;&gt;Dependencies 🌱&lt;/h4&gt;

&lt;p&gt;每个 target 都可以有依赖，这些依赖是 target 需要链接的那些 framework 以及 library等，其包含了能够被 target 共享的源代码以及资源。这些依赖项可以被静态或者动态的链接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;静态链接：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;发生在编译阶段；&lt;/li&gt;
&lt;li&gt;库（Library）中的代码文件会被包含到应用的二进制文件中（会增大应用的二进制大小）；&lt;/li&gt;
&lt;li&gt;库使用 .a 作为文件后缀，其来自 (ar)chive file3 type；&lt;/li&gt;
&lt;li&gt;如果相同的库被多次链接，编译器会由于 duplicated symbols 编译失败。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;动态链接：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;模块在应用启动或者运行过程中被加载；&lt;/li&gt;
&lt;li&gt;应用或者扩展的 target 都可以共享相同的动态库（仅被复制一份）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于 framework 和 library（无论是静态链接还是动态链接）的区别在于前者可以在相同的 bundle 中包含多个版本，还可以包含额外的资源文件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个 Library 是一个 .a 文件，其来源于 归档（archive）文件类型。一个单一的归档文件仅支持单一的架构。如果需要打包多个架构，则需要将其打包成胖Match-O二进制（&lt;strong&gt;fat Match-O binary&lt;/strong&gt;），该二进制文件是一种容器格式，其将支持不同架构的Mach-O打包在一起。如果我们想生成、修改一个胖二进制文件或者从其中提取某个特定架构的库的话，可以使用命令行工具&lt;code&gt;lipo&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以在&lt;a href=&#34;https://pewpewthespells.com/blog/static_and_dynamic_libraries.html&#34;&gt;这里&lt;/a&gt;了解更多关于 frameworks/libraries 以及 static/dynamic 的内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/qKHdwhp.png&#34; alt=&#34;动态链接和静态链接的区别&#34; /&gt;&lt;/p&gt;

&lt;p&gt;应用的依赖项分为预编译过的（&lt;strong&gt;precompiled&lt;/strong&gt;）和未经编译过（&lt;strong&gt;not-compiled&lt;/strong&gt;）两类。&lt;/p&gt;

&lt;h5 id=&#34;precompiled-dependencies&#34;&gt;Precompiled dependencies&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/carthage&#34;&gt;Carthage&lt;/a&gt; 是这类型依赖的典型代表。某些 SDK，比如 &lt;a href=&#34;https://github.com/CocoaPods/Specs/blob/master/Specs/0/3/5/Firebase/4.2.0/Firebase.podspec.json#L23&#34;&gt;Firebase&lt;/a&gt; 就是作为编译过的依赖来发布的。当预编译过的依赖是库（library）的时候，这些依赖就包含 &lt;code&gt;.a&lt;/code&gt; 的库及一个公共头文件，包含了该库所暴露出的公共接口。当这些依赖是 framework 的时候，这些依赖就以包含了库和资源文件的 &lt;code&gt;.framework&lt;/code&gt; 文件发布。&lt;/p&gt;

&lt;p&gt;当我们的 app 依赖的是预编译依赖的时候，很重要的一点是，这些依赖也是依照我们 app 所构建架构来构建出来的。一旦其中缺失某个架构的代码，我们就会在编译 app 的时候收到编译错误。一会儿后文会看到，Carthage 使用 lipo 工具生成那些包含模拟器或者真机所必须的架构的 framework 的，同时根据构建配置来剔除掉那些不需要的 framework。&lt;/p&gt;

&lt;h5 id=&#34;non-compiled-dependencies&#34;&gt;Non-compiled dependencies&lt;/h5&gt;

&lt;p&gt;&lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; 是该种类型的典型代表。依赖项被定义在我们要链接的 frameworks/libraries 的 target 中。这里有多种方式在 Xcode 中指定我们的 target 依赖其他 target 的输出。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果这些 target 分布在同一个 project 中&lt;/strong&gt;，你可以在 Build Phase 的&lt;em&gt;Target dependencies&lt;/em&gt; 中指定依赖。 Xcode 会在编译该 target 的时候首先编译这些指定的依赖项；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果这些 target 分布在不同的 project 中&lt;/strong&gt;，我们就可以使用*Scheme*来定义这些 target 之间的依赖关系。在 scheme 的 Build 部分，我们可以定义要被构建的 target 以及以什么顺序构建（基于他们之间的依赖关系）。如果你开启了*Find implicit dependencies*标识，Xcode 能够根据每个 target 的输入输出来猜测依赖。如果 scheme 中有错误配置，你就会得到类似&lt;code&gt;xxxx.framework not found&lt;/code&gt;的错误。如果在 framework 之间出现了循环依赖也会报类似的错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;关于依赖项和配置项有个需要注意的地方：所有依赖项的配置一定要完全匹配。如果你在使用 Alpha 配置项构建你的 app，但是其依赖项中但凡出现了不包含这种配置，编译过程都会因为找不到某个 framework 而失败。当这种情况发生的时候，Xcode 不会编译该 framework 但是不报任何错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/TrXKUTJ.png&#34; alt=&#34;各个依赖项是如何基于 project 的配置得到编译的&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;linking-with-xcode&#34;&gt;Linking with Xcode&lt;/h3&gt;

&lt;p&gt;Target 本身可以链接其他 target 的输出，我们可以使用 Xcode 中的工具，比如 scheme 或者 target dependencies 来指定依赖，但是，我们是如何通过定义这些依赖的链接关系来将它们融为一体的？&lt;/p&gt;

&lt;h4 id=&#34;1-动态或者静态链接-libraries-和-frameworks&#34;&gt;1. 动态或者静态链接 libraries 和 frameworks&lt;/h4&gt;

&lt;p&gt;我们可以通过以下的方式定义链接：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个构建阶段（build phase）：&lt;/strong&gt;，在所有可用的 build phase 中，有一个是定义链接的，*Link Binary With Libraries*。你可以在这里添加某个 target 的依赖项，这些依赖项可以来自于同一个 project，也可以来自同一个 workspace 中的其他 project。这个 build phase 被 Xcode 用来识别 target 被构建时所需的依赖项；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译器构建设置：&lt;/strong&gt;一个 build phase 中所定义的内容会被转换成编译器参数。其中某些内容你也可以通过定义编译设置项做到：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FRAMEWORK_SEARCH_PATHS&lt;/code&gt;：定义编译器所链接的 framework 所在路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIBRARY_SEARCH_PATHS&lt;/code&gt;：定义编译器所链接的 library 所在路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OTHER_LDFLAGS&lt;/code&gt; *(Other Linker Flags)*：我们可以使用&lt;code&gt;-l&lt;/code&gt;参数指定链接的 library，比如&lt;code&gt;-l&amp;quot;1PasswordExtension&amp;quot; -l&amp;quot;Adjust&amp;quot;&lt;/code&gt;。如果需要链接一个 framework，就需要使用&lt;code&gt;-framework&lt;/code&gt;参数，比如：&lt;code&gt;-framework &amp;quot;GoogleSignIn&amp;quot; -framework &amp;quot;HockeySDK&amp;quot;&lt;/code&gt;。如果我们尝试链接一个无法在上方指定路径中找到的 framework 或者 library 的话，编译过程就会失败。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-暴露库的头文件&#34;&gt;2. 暴露库的头文件&lt;/h4&gt;

&lt;p&gt;Library 的头文件需要暴露给依赖该库的 targe。为了做到这个，有一个编译设置项：&lt;code&gt;HEADER_SEARCH_PATHS&lt;/code&gt;用来指定头文件所在路径。如果我们链接某个库，但是忘记暴露该库的头文件，编译过程就会因为找不到其头文件而失败。&lt;/p&gt;

&lt;h4 id=&#34;3-将-framework-嵌入到应用中&#34;&gt;3. 将 Framework 嵌入到应用中&lt;/h4&gt;

&lt;p&gt;App 的 target 链接动态 framework，需要把这些依赖项复制到应用的 bundle 中。这个过程被称作 &lt;strong&gt;framework embedding&lt;/strong&gt;。为了达到这个目的，我们需要使用 Xcode 的&lt;strong&gt;Copy Files Phase&lt;/strong&gt;，其拷贝 这些 framework 到 &lt;code&gt;Frameworks&lt;/code&gt;目录中。不仅仅需要把这些直接依赖项嵌入应用中，还包括直接依赖所依赖的项目。如果缺少任意的 framework，当我们尝试打开 app 的时候都会抛出错误。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;案例学习&#34;&gt;案例学习 👨‍💻&lt;/h3&gt;

&lt;p&gt;在这个部分，我们会分析以下 Cocopods 和 Carthage 是如何贯彻上面这些概念来管理你的工程依赖的。&lt;/p&gt;

&lt;h4 id=&#34;cocoapods&#34;&gt;CocoaPods&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/yYLLsbQ.png&#34; alt=&#34;CocoaPods&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cocoapods 解析你的工程依赖，并将它们融合到你的工程中。虽然直接修改你的工程配置是不太推荐的，但是它从最初的版本已经有了很大的提升，用这种方式，我们几乎不需要对 project 做很多改变。那么它底层到底是怎么做到的？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它创建一个工程（project）&lt;em&gt;(&lt;/em&gt;&lt;code&gt;*Pods.xcodeproj*&lt;/code&gt;&lt;em&gt;)&lt;/em&gt; ，其包含了所有的依赖项，每个依赖项以 target 的形式存在。每个 target 各自编译需要被链接到 app 中的依赖项；&lt;/li&gt;
&lt;li&gt;它创建一个额外的 target，其依赖于其他所有的依赖项。该 target 是一个 umbrella target，用来触发其他 target 的编译。这样做也最小程度的减少了你的 project 中所需要的改变。通过链接这个 target，Xcode 会先编译其所有依赖项，然后是你的 app；&lt;/li&gt;
&lt;li&gt;它创建了一个 workspace，包含了你的 project 以及 Pods project；&lt;/li&gt;
&lt;li&gt;Frameworks 和 libraries 使用&lt;code&gt;.xcconfig&lt;/code&gt;文件链接。这些文件被加到了你的 project 群组中，并且被设置为你 project 中 target 的配置项；&lt;/li&gt;
&lt;li&gt;嵌入过程是通过一个构建阶段脚本（build phase script）来做到的。类似的，所有的 framework 所需要的资源也通过一个构建阶段（build phase）来完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这张图展示了整个设置过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/UARMUhl.png&#34; alt=&#34;CocoaPods 如何将依赖项融合到整个 Project 中&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;carthage&#34;&gt;Carthage&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/IUXCxhQ.png&#34; alt=&#34;Carthage&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Carthage 的方式和 CocoaPods 比起来大不同。除了依赖项的解析，该工具是还一种去中心化的模式，其生成那些需要被链接或者嵌入到 app 的依赖项的预编译版本。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Carthage 解析依赖项，并且编译它们生成你能够链接到 app 中的动态 framework，或者为了调试所需要的符号。这些 framework 是 fat framework，支持模拟器和真机的架构；&lt;/li&gt;
&lt;li&gt;这些 framework 被用户使用 &lt;em&gt;Link Binary With Libraries&lt;/em&gt; 的构建阶段（build phase）手动的链接；&lt;/li&gt;
&lt;li&gt;嵌入过程使用 Carthage 提供的脚本完成。这个脚本会剔除那些我们正在构建目标所不必要的架构版本；&lt;/li&gt;
&lt;li&gt;使用同样的脚本，复制符号到合适的文件夹，使得调试能够正常进行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/HXqtoDl.png&#34; alt=&#34;Carthage 是如何生成依赖项的 framework 和 symbol&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.knowstack.com/framework-vs-library-cocoa-ios/&#34;&gt;Framework vs Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pewpewthespells.com/blog/static_and_dynamic_libraries.html&#34;&gt;Static and dynamic libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pewpewthespells.com/blog/buildsettings.html&#34;&gt;Xcode Build Settings Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/content/technotes/tn2435/_index.html&#34;&gt;Embedding Frameworks in an App&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html&#34;&gt;Introduction to Framework Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cocoanetics.com/2015/04/skipping-copy-phase-strip/&#34;&gt;Skippy Copy Phase Strip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Initializer in Swift</title>
      <link>https://hechen.xyz/post/initializer-in-swift/</link>
      <pubDate>Wed, 15 Nov 2017 13:09:27 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/initializer-in-swift/</guid>
      
        <description>

&lt;p&gt;我想 &lt;code&gt;[[xxx alloc] init]&lt;/code&gt; 应该是自己接触 iOS 开发以来写的最多的语句了吧。一个对象初始化是其得以存在的前提，无论你是使用 new 关键字与否，根本上都会执行到 init 方法。&lt;/p&gt;

&lt;p&gt;转入 swift 语言之后，在刚接触的时候经常会因为自建初始化方法不合适，编译器报一堆错误，很是痛苦，但是当理解 Swift 语言为了保障安全的初始化行为所做的工作之后，你就会明白，Swift 初始化方法是有一定的规范要求的。&lt;/p&gt;

&lt;p&gt;这篇文章是想做个记录。&lt;/p&gt;

&lt;h3 id=&#34;初始化方法&#34;&gt;初始化方法&lt;/h3&gt;

&lt;p&gt;顺序很重要！&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;Objective-C&lt;/code&gt; 中不同，Swift 语言会保证某个类的所有属性均被初始化才行。因此初始化方法会非常严格，那第一点需要保障的就是&lt;strong&gt;顺序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;首先，祭出这张官方镇宅图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;media/initializerDelegation02_2x.png&#34; alt=&#34;initializerDelegation02_2x&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在某个类的子类中，初始化方法语句的顺序并不是随意的，我们需要保证在当前子类实例的成员初始化完成后才能调用父类的初始化方法。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>处理 Swift 中非可选的可选值类型</title>
      <link>https://hechen.xyz/post/handling-non-optional-optionals-in-swift/</link>
      <pubDate>Tue, 14 Nov 2017 21:53:52 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/handling-non-optional-optionals-in-swift/</guid>
      
        <description>

&lt;p&gt;可选值（optionals）无可争议的是 &lt;code&gt;swift&lt;/code&gt; 语言中最重要的特性之一，也是和其他语言，例如 &lt;code&gt;Objective-C&lt;/code&gt; 的最大区别。通过强制处理那些有可能出现 &lt;code&gt;nil&lt;/code&gt; 的地方，我们就能写出更有预测性的以及更健壮的代码。&lt;/p&gt;

&lt;p&gt;然而，有些时候可选值可能会致你于尴尬的境地，尤其是你作为开发者了解（甚至是有些猜测的成分在），有的特定变量始终是非空（non-nil）的，即使它是一个可选类型。例如，我们在一个视图控制器中处理视图的时候：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TableViewController: UIViewController {
    var tableView: UITableView?

    override func viewDidLoad() {
        super.viewDidLoad()
        tableView = UITableView(frame: view.bounds)
        view.addSubview(tableView!)
    }

    func viewModelDidUpdate(_ viewModel: ViewModel) {
        tableView?.reloadData()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是对于很多 Swift 程序员争论比较激烈的地方，程度不亚于讨论 tabs 和 spaces 的用法。有的人会说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;既然它是一个可选值，你就应该时刻使用 &lt;code&gt;if let&lt;/code&gt; 或者 &lt;code&gt;guard let&lt;/code&gt; 的方式进行解包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而另外一些人则采用完全相反，说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;既然你知道这个变量在使用的时候不会为 &lt;code&gt;nil&lt;/code&gt;，使用 &lt;code&gt;!&lt;/code&gt; 强制解包多好。崩溃也要比让你的程序处于一个未知状态要好吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本质上来讲，我们这里讨论的是要不要采用防御性编程（&lt;a href=&#34;https://en.wikipedia.org/wiki/Defensive_programming&#34;&gt;defensive programming&lt;/a&gt;）的问题。我们是试图让程序从一个未知状态恢复还是简单的放弃，然后让它崩溃掉？&lt;/p&gt;

&lt;p&gt;如果非得让我对这个问题给出一个答案的话，我更倾向于后者。未知状态真的很难追踪 bug，会导致执行很多不想执行的逻辑，采用防御性编程就会使得你的代码很难追踪，出现问题很难追踪。&lt;/p&gt;

&lt;p&gt;但是，我不太喜欢给出一个二选一的答案。相反，我们可以寻找一些技术手法，用更精妙的方式的解决上面提到的问题。&lt;/p&gt;

&lt;h2 id=&#34;它真的可选的吗&#34;&gt;它真的可选的吗？&lt;/h2&gt;

&lt;p&gt;那些可选类型的，但是被代码逻辑真实需要的变量和属性，实际上是架构瑕疵的一个体现。如果在某些地方确实需要它，但是它又不在，就会使得你的代码逻辑处于未知状态，那么它就不应该是可选类型的。&lt;/p&gt;

&lt;p&gt;当然，在某些特定场景下，可选值确实很难避免（尤其是和特定的系统 API 交互的时候），那对于大部分这种情况，我们有一些技术来处理从而避免可选值。&lt;/p&gt;

&lt;h3 id=&#34;lazy-要比非可选的可选值更好&#34;&gt;lazy 要比非可选的可选值更好&lt;/h3&gt;

&lt;p&gt;某些属性的值需要在其父类创建之后再生成（比如视图控制器中的那些视图，应该在 &lt;code&gt;loadView()&lt;/code&gt;或者 &lt;code&gt;viewDidLoad()&lt;/code&gt;方法中被创建），对于这种属性要避免其可选类型的方法就是使用 &lt;code&gt;lazy&lt;/code&gt; 属性。一个&lt;code&gt;lazy&lt;/code&gt;属性是可以是非可选类型的，同时也不在其父类的初始化方法里被需要，它会在其第一次被获取的时候创建出来。&lt;/p&gt;

&lt;p&gt;让我们改一下上面的代码，使用 lazy 来改造 tableView 属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TableViewController: UIViewController {
    lazy var tableView = UITableView()

    override func viewDidLoad() {
        super.viewDidLoad()
        tableView.frame = view.bounds
        view.addSubview(tableView)
    }

    func viewModelDidUpdate(_ viewModel: ViewModel) {
        tableView.reloadData()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，没有可选值了，也不会有未知状态咯🎉&lt;/p&gt;

&lt;h3 id=&#34;适当的依赖管理要比非可选的可选值要好&#34;&gt;适当的依赖管理要比非可选的可选值要好&lt;/h3&gt;

&lt;p&gt;可选值类型另外一种常用的场景就是用来打破循环依赖（&lt;a href=&#34;https://en.wikipedia.org/wiki/Circular_dependency&#34;&gt;circular dependencies&lt;/a&gt;）。有的时候，你就陷入 A 依赖 B，B 又依赖 A 的情况，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UserManager {
    private weak var commentManager: CommentManager?

    func userDidPostComment(_ comment: Comment) {
        user.totalNumberOfComments += 1
    }

    func logOutCurrentUser() {
        user.logOut()
        commentManager?.clearCache()
    }
}

class CommentManager {
    private weak var userManager: UserManager?

    func composer(_ composer: CommentComposer
                  didPostComment comment: Comment) {
        userManager?.userDidPostComment(comment)
        handle(comment)
    }

    func clearCache() {
        cache.clear()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码，我们可以看到，&lt;code&gt;UserManager&lt;/code&gt; 和 &lt;code&gt;CommentManager&lt;/code&gt; 之间有一个循环依赖的问题，它们二者都没法假设自己拥有对方，但是它们都在各自的代码逻辑里依赖彼此。这里就很容易产生 bug。&lt;/p&gt;

&lt;p&gt;那要解决上面的问题，我们创建一个 &lt;code&gt;CommentComposer&lt;/code&gt; 来做一个协调者，负责通知&lt;code&gt;UserManager&lt;/code&gt; 和 &lt;code&gt;CommentManager&lt;/code&gt;二人一个评论产生了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class CommentComposer {
    private let commentManager: CommentManager
    private let userManager: UserManager
    private lazy var textView = UITextView()

    init(commentManager: CommentManager,
         userManager: UserManager) {
        self.commentManager = commentManager
        self.userManager = userManager
    }

    func postComment() {
        let comment = Comment(text: textView.text)
        commentManager.handle(comment)
        userManager.userDidPostComment(comment)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这种形式，UserManager 可以强持有 CommentManager 也不产生任何依赖循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UserManager {
    private let commentManager: CommentManager

    init(commentManager: CommentManager) {
        self.commentManager = commentManager
    }

    func userDidPostComment(_ comment: Comment) {
        user.totalNumberOfComments += 1
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们又一次的移除了所有的可选类型，代码也更好预测了🎉。&lt;/p&gt;

&lt;h3 id=&#34;优雅的崩溃-crashing-gracefully&#34;&gt;优雅的崩溃（Crashing gracefully）&lt;/h3&gt;

&lt;p&gt;通过上面几个例子，我们通过对代码做一些调整，移除了可选类型从而排除了不确定性。然而，有的时候，移除可选类型是不可能的。让我们举个例子，比如你在加载一个本地的包含针对你 App 的配置项的 JSON 文件，这个操作本身一定会存在失败的情况，我们就需要添加错误处理。&lt;/p&gt;

&lt;p&gt;继续上面这个场景，加载配置文件失败的时候继续执行代码就会使得你的 app 进入一个未知状态，在这种情况下，最好的方式让它崩溃。这样，我们会得到一个崩溃日志，希望这个问题能够在用户感知之前早早的被我们的测试人员以及 QA 处理掉。&lt;/p&gt;

&lt;p&gt;所以，我们如何崩溃。。。最简单的方式就是添加 &lt;code&gt;!&lt;/code&gt; 操作符，针对这个可选值强制解包，就会在其是 nil 的时候发生崩溃：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let configuration = loadConfiguration()!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然这个方法比较简单，但是它有个比较大的问题，就是一旦这段代码崩溃，我们能得到的只有一个错误信息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;fatal error: unexpectedly found nil while unwrapping an Optional value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个错误信息并不告诉我们为什么发生这个错误，在哪里发生的，给不了我们什么线索来解决它。这个时候，我们可以使用 guard 关键字，结合 &lt;code&gt;preconditionFailure()&lt;/code&gt; 函数，在程序退出的时候给出定制消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let configuration = loadConfiguration() else {
    preconditionFailure(&amp;quot;Configuration couldn&#39;t be loaded. &amp;quot; +
                        &amp;quot;Verify that Config.JSON is valid.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码发生崩溃的时候，我们就能获得更多更有效的错误信息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;fatal error: Configuration couldn’t be loaded. Verify that Config.JSON is valid.: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样，我们现在有了一个更清晰的解决问题的办法，能够准确的知道这个问题在我们代码里的哪个未知发生的。&lt;/p&gt;

&lt;h3 id=&#34;引入-require-库&#34;&gt;引入 Require 库&lt;/h3&gt;

&lt;p&gt;使用上面的 guard-let-preconditionFailure 的方案还是有一些冗长，确实让我们呃代码更难驾驭。我们也确实不希望在我们的代码里占很多篇幅去些这种代码，我们想更专注于我们的代码逻辑上。&lt;/p&gt;

&lt;p&gt;我的解决方案就是使用 &lt;code&gt;Require&lt;/code&gt;。它只是简单的在可选值添加简单的 &lt;code&gt;require()&lt;/code&gt; 方法，但能够使得调用的地方更简洁。用这种方法来处理上面加载 &lt;code&gt;JSON&lt;/code&gt; 文件的代码就可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let configuration = loadConfiguration().require(hint: &amp;quot;Verify that Config.JSON is valid&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当出现异常的时候，会给出下面的错误信息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;fatal error: Required value was nil. Debugging hint: Verify that Config.JSON is valid: file /Users/John/AmazingApp/Sources/AppDelegate.swift, line 17&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Require&lt;/code&gt; 的另一个优势就是它和调用 &lt;code&gt;preconditionFailure()&lt;/code&gt; 方法一样也会抛异常 &lt;code&gt;NSException&lt;/code&gt;，就能使得那些异常上报工具能够捕获异常发生时候的元数据。&lt;/p&gt;

&lt;p&gt;你如果想在自己代码中使用的话，&lt;a href=&#34;https://github.com/JohnSundell/Require.git&#34;&gt;Require 现在在 Github 上开源了&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;所以，总结来看，在 &lt;code&gt;Swift&lt;/code&gt; 语言里处理那些非可选的可选值，我有几点自己的贴心小提示给大家：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;lazy&lt;/code&gt; 属性要比非可选的可选值要更好&lt;/li&gt;
&lt;li&gt;适当的依赖管理要比非可选的可选值要好&lt;/li&gt;
&lt;li&gt;当你使用非可选的可选值的时候，优雅的崩溃&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果有任何问题、建议或者反馈，都欢迎随时在 &lt;a href=&#34;https://twitter.com/johnsundell&#34;&gt;Twitter&lt;/a&gt; 上联系我，我非常乐意听到你们希望我在接下来的文章里谈论哪些主题哦。&lt;/p&gt;

&lt;p&gt;谢谢阅读。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>理解响应者和响应链</title>
      <link>https://hechen.xyz/post/understanding-responders-and-the-responder-chain/</link>
      <pubDate>Mon, 13 Nov 2017 21:22:44 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/understanding-responders-and-the-responder-chain/</guid>
      
        <description>

&lt;p&gt;Apps 是通过响应者（responder）对象来接收和处理事件的。一个响应者对象是 UIResponder 类的一个实例，我们常见的 UIView，UIViewController 以及 UIApplication 都是 UIResponder 的子类。 UIKit 自动帮你管理着这些 responder 相关的行为，包括事件是如何从一个 responder 传递给另一个 responder 的等等。当然，你也可以修改你的 app 中事件传递的默认行为。&lt;/p&gt;

&lt;p&gt;UIKit 会把大部分的事件都传递给最适合的 responder 对象来处理。如果该 responder 无法处理该事件，UIKit 就会继续把该事件沿着当前的响应者链传递到下一个 responder。响应者链就是你的 App 中所有响应者的动态配置，也因为其是动态的，你的 App 中不可能只存在单一的响应者链。由于事件总是从特定的响应者那里流转到更通用的响应者那里，因此很容易确定某响应者链中下一个响应者是谁。举个例子，一个 view 的下一个响应者是其 superview 或者负责管理它的 view controller。事件就是这样在响应者链中传递直到其被处理掉。&lt;/p&gt;

&lt;p&gt;下图1 表明一个界面中包含了 一个 Label，一个 text field，一个 button 以及两个 background view 的 App 中响应链是什么样子的。如果 text field 不处理某个事件，UIKit 就会把该事件发送给 text field 的父级 UIView 对象，同样的，如果该对象依然处理不了，就会传递给该 view 对象的 window。如果 window 对象也依然无法处理该事件，UIKit 最终会把该事件传递给 UIApplication 对象，一般上该 UIApplication 对象是 App 的 delegate 对象并且是 UIResponder 实例，当然这个时候已经脱离了响应者链了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws4.sinaimg.cn/large/006tKfTcly1flgs9djns2j30zp0lyac6.jpg&#34; alt=&#34;图1 - 一个响应者链的例子&#34; /&gt;&lt;/p&gt;

&lt;p&gt;针对每一个事件，UIKit 都会指定一个第一响应者（first responder），然后把该事件首先发送给对象处理。这个第一响应者基于事件类型而不同。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Touch events.&lt;/strong&gt; 第一响应者是 Touch 发生所在的 view。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Press events.&lt;/strong&gt; 第一响应者是当前焦点所在的响应者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Motion event.&lt;/strong&gt; 第一响应者是你显式指定用以处理事件的对象。 Core Motion 处理所有的和加速器、气压仪以及磁力计相关的事件。Motion events 不随响应者链流动。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shake-motion events.&lt;/strong&gt; 第一响应者是你或者 UIKit 框架指定的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remote-control events.&lt;/strong&gt; 第一响应者是你或者 UIKit 框架指定的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Editing-menu messages.&lt;/strong&gt; 第一响应者是你或者 UIKit 框架指定的对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Controls 向其关联的对象发送动作消息本身不是事件，但是依然能够享受到响应者链的好处。当一个 Control 的 target object 是 nil 的时候，UIKit 就会在该 target object 的响应者链上寻找合适的对象用以妥善处理动作消息。例如，UIKit 编辑按钮使用这种行为来寻找响应者对象来执行&lt;code&gt;cut:&lt;/code&gt;, &lt;code&gt;copy:&lt;/code&gt; 或者 &lt;code&gt;paste:&lt;/code&gt; 等方法。&lt;/p&gt;

&lt;p&gt;如果一个 view 自身还有附加的手势识别器的话，该手势识别器会延迟针对该 view 的 touch 和 press 事件的传递。&lt;code&gt;delaysTouchesBegan&lt;/code&gt;, &lt;code&gt;delaysTouchesEnded&lt;/code&gt; 以及 &lt;code&gt;UIGestureRecognizer&lt;/code&gt; 的 &lt;code&gt;cancelsTouchesInView&lt;/code&gt; 属性都是用来决定这些 touches 什么时间以及以什么方式被延迟处理。&lt;/p&gt;

&lt;h3 id=&#34;识别包含-touch-事件的响应者&#34;&gt;识别包含 Touch 事件的响应者&lt;/h3&gt;

&lt;p&gt;UIKit 使用基于视图的碰撞检测（hit-testing）来决定 touch 事件发生的地点。具体而言，UIKit  拿该 touch 的位置和视图层级中所有的视图对象的 bounds 进行比较。UIView 的 &lt;code&gt;hitTest:withEvent:&lt;/code&gt; 方法会游历整个视图层级，找到该 touch 事件发生所在的视图树最底端的视图，其也就是处理该 touch 事件的第一响应者。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果一个 touch 的位置发生在某个视图的外围，&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法就会忽略该视图和其所有子视图。所以，如果你将 view 的&lt;code&gt;clipsToBounds&lt;/code&gt;属性设置为 NO 的化，即使其子视图将该 touch 包含在自己领域也是无效的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就这样，UIKit 持续不断的把每个 touch 指派给包含该 touch 的视图。当 touch 发生的时候，UIKit 创建一个 &lt;code&gt;UITouch&lt;/code&gt; 对象，直到 touch 结束该对象才会被释放。当 touch 位置或者其他参数发生变化的时候，UIKit 就更新这个 UITouch 对象的信息。当然，其中有的属性当然是不会变化的，比如该 touch 附属的 view，甚至当 touch 位置已经超出原始 view 的外围的时候，UITouch 对象中的 view 属性依然保持和之前一样。&lt;/p&gt;

&lt;h3 id=&#34;变更响应者链&#34;&gt;变更响应者链&lt;/h3&gt;

&lt;p&gt;你可以通过覆写响应者的 nextResponder 属性来改变响应者链。许多 UIKit 的类已经覆写了该方法并且返回了特定的对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果你覆写了任意类的 &lt;code&gt;nextResponder&lt;/code&gt; 属性，那该对象的下一个响应者就是你返回的那个；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIView&lt;/code&gt;
2.1 如果该视图是某个视图控制器的根视图（root view），其下一个响应者就是该视图控制器；
2.2 如果该视图不是某个视图控制器的根视图，其下一个响应者就是该视图的父视图；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIViewController&lt;/code&gt;
3.1 如果该视图控制器的视图是某个 window 的根视图（root view），其下一个响应者就是 window；
3.2 如果该视图控制器是由另一个视图控制器展示出来的，其下一个响应者就是那个视图控制器（presenting view controller）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIWindow&lt;/code&gt;  window 的下一个响应者就是 &lt;code&gt;UIApplication&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIApplication&lt;/code&gt;  UIApplication 对象的下一个响应者是 App delegate，而且要求该 delegate 必须是 &lt;code&gt;UIRepsponder&lt;/code&gt; 的实例并且不能是一个视图、视图控制器或者 &lt;code&gt;UIApplication&lt;/code&gt; 对象自己。&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>Capturing objects in Swift closures</title>
      <link>https://hechen.xyz/post/capturing-objects-in-swift-closures/</link>
      <pubDate>Sun, 12 Nov 2017 20:56:50 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/capturing-objects-in-swift-closures/</guid>
      
        <description>

&lt;p&gt;自从 Block 在 iOS4 被引入 Objective-C 的世界之后就成为了 Apple 各平台上最时髦的 API 的重要组成部分了。当 Swift 语言出现的时候，blocks 的概念就摇身一变通过 closure 的形式引入，成为了目前我们可能每一天都在用的语言特性之一了。&lt;/p&gt;

&lt;p&gt;Closure 目前已经被我们广泛的使用了，即使如此，我们在使用它的时候还是需要有很多需要注意的点，并且需要做很多额外的操作。这篇文章，我们来近距离的了解 closure，主要是了解其捕获变量的机制以及那些能够更好的让我们来处理变量捕获的技术。&lt;/p&gt;

&lt;h2 id=&#34;伟大的-escape&#34;&gt;伟大的 escape&lt;/h2&gt;

&lt;p&gt;Closure 有两种类型：escaping 和 non-escaping。当一个 closure 是 escaping（使用 &lt;code&gt;@escaping&lt;/code&gt; 修饰闭包参数）的，也就意味着其会被以各种形式存储下来（无论是通过 property 还是被其他 closure 捕获）。相反，Non-Escaping 的　closure 意味着其不能被存储，而且在使用它的地方就必须直接被执行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;译者注： 可以参见 &lt;a href=&#34;http://hechen.info/2017/11/12/autoclosure-escape/&#34;&gt;《@autoclosure &amp;amp;&amp;amp; @escape》&lt;/a&gt; 一文。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个显而易见的例子就是当你在一个集合类型上使用函数式操作的时候，例如 &lt;code&gt;forEach&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3].forEach { number in
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码所示，closure 都直接作用于集合的每一个元素上，也就无需把该闭包变为 escaping 的。&lt;/p&gt;

&lt;p&gt;而 escaping 的 closures 最常见的就是在那些异步 API 中，例如 &lt;code&gt;DispatchQueue&lt;/code&gt;。例如，当你异步执行某 closure 的时候，这个 closure 就会 escape。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DispatchQueue.main.async {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，这两种的区别在哪里呢？ 由于 escaping 的 closure 会被以某种形式存储下来，因此，这些 closure 会同时存储当前其所处的上下文，同时就会把上下文中用到的值或者对象都捕获（capture）到，以至于当该 closure 被执行的时候，所需用到的内容没有丢失。实践中最常见的就是在 closure 中使用 self 的 API，此时，我们就需要某种办法显式的捕获 self。&lt;/p&gt;

&lt;h2 id=&#34;捕获-引用循环&#34;&gt;捕获 &amp;amp; 引用循环&lt;/h2&gt;

&lt;p&gt;因为 escaping 的 closures 会自助捕获在其内部使用的任何值和对象，因此很容易发生引用循环。举个例子，下面描述的是一个 view controller 被其存储的 viewModel 的 closure 捕获的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ListViewController: UITableViewController {
    private let viewModel: ListViewModel

    init(viewModel: ListViewModel) {
        self.viewModel = viewModel

        super.init(nibName: nil, bundle: nil)

        viewModel.observeNumberOfItemsChanged {
            // This will cause a retain cycle, since our view controller
            // retains its view model, which in turn retains the view
            // controller by capturing it in an escaping closure.
            self.tableView.reloadData()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最常见的方式，也就是你们大部分人也都会用的解决方式，通过弱引用的方式打破这个循环引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;viewModel.observeNumberOfItemsChanged { [weak self] in
    self?.tableView.reloadData()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;捕获-context-而不是捕获-self&#34;&gt;捕获 context 而不是捕获 self&lt;/h2&gt;

&lt;p&gt;上面提到的 [weak self] 的解决方案已经是你希望避免引用循环的最常用，也常常是最有效的解决方案了。但是这种方式也有一些问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;很容易忘掉写，尤其是编译器又没检查出来潜在的引用循环的时候；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当你希望从 weak self 中强持有 self 的时候还需要写一堆代码（weak strong dance），例如下面这段代码所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dataLoader.loadData(from: url) { [weak self] data in
guard let strongSelf = self else {
    return
}

let model = try strongSelf.parser.parse(data, using: strongSelf.schema)
strongSelf.titleLabel.text = model.title
strongSelf.textLabel.text = model.text
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里其实有一个可选的解决方案，也就是不要捕获 self，而去捕获那些闭包中所需要的对象即可。例如上面例子中的 labels 和 schema 等，我们可以直接捕获它们而不至于引发引用循环（因为其也并不持有 closure 本身），下面是个解决方案，通过使用 context 的 tuple 来解决。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// We define a context tuple that contains all of our closure&#39;s dependencies
let context = (
    parser: parser,
    schema: schema,
    titleLabel: titleLabel,
    textLabel: textLabel
)

dataLoader.loadData(from: url) { data in
    // We can now use the context instead of having to capture &#39;self&#39;
    let model = try context.parser.parse(data, using: context.schema)
    context.titleLabel.text = model.title
    context.textLabel.text = model.text
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通过显式传递参数而不是隐式的捕获&#34;&gt;通过显式传递参数而不是隐式的捕获&lt;/h2&gt;

&lt;p&gt;这里，还有另外一种捕获对象的方式，就是显式的把这些对象通过参数传入。这种手法我在设计我的 [Image Engine]() 项目中的 Event API 的时候用到了，这个 API 就是当使用 closure 来监听 event 的时候，需要你传递一个 observer 给它。如下所示，你把 self 传入进来的同时也使得其被传递到了 event 的 closure 中了，这也使得 self 被隐式的带入，你也无需手动的捕获它了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actor.events.moved.addObserver(self) { scene in
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们回到之前的 ListViewController 的例子中，看一看当我们要监听其 viewModel 的时候，我们是如何通过上面这种手法来实现同样的 API 的。这种方式正好使得我们可以将要 reload 的 tableView 作为观测者传递，实现一个很优雅的调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;viewModel.numberOfItemsChanged.addObserver(tableView) { tableView in
    tableView.reloadData()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，需要实现上面这段代码，我们还需要做一些事情，就像 Image Engine 的事件系统如何工作类似。我们首先定义一个简单的 Event 类型，其可以记录那些观测闭包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Event {
    private var observers = [() -&amp;gt; Void]()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，我们添加一个方法，该方法会传两个参数进来，一个是引用类型的观测者，另外一个是一个闭包，当观察动作一旦触发，该闭包就会被调用。核心就在这里，我们会封装该闭包，并且在内部闭包中弱捕获该观测者：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func addObserver&amp;lt;T: AnyObject&amp;gt;(_ observer: T, using closure: @escaping (T) -&amp;gt; Void) {
    observers.append { [weak observer] in
        observer.map(closure)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就使得我们只需要做这么一次 weak/string 的操作，也不影响其调用的地方。&lt;/p&gt;

&lt;p&gt;最后，我们添加一个 trigger 方法来使得我们能够触发事件本身。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func trigger() {
    for observer in observers {
        observer()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后回到 &lt;code&gt;ListViewModel&lt;/code&gt;，为 &lt;code&gt;numberOfItemsChanged&lt;/code&gt; 方法添加事件，当某个条件满足的时候，就会触发该事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ListViewModel {
    let numberOfItemsChanged = Event()
    var items: [Item] { didSet { itemsDidChange(from: oldValue) } }

    private func itemsDidChange(from previousItems: [Item]) {
        if previousItems.count != items.count {
            numberOfItemsChanged.trigger()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上面所看到的，基于 event 的 API 的最大优势就是最大程度上避免了引用循环的发生。我们也可以在我们的代码中为任意类型的观察事件重用相同的执行代码。当然，上面的 demo 中 Event 实现非常简单，缺乏一些高级特性，比如针对观察者的移除等等，但是对于简单使用已经足够了。&lt;/p&gt;

&lt;p&gt;我们会在之后的博文中详细的讲述事件驱动的编程范式，你也可以详细看下在 Image Engine 项目中的 &lt;a href=&#34;https://github.com/JohnSundell/ImagineEngine/blob/master/Sources/Core/API/Event.swift&#34;&gt;Event 类型的完整实现&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;Closure 自动捕获其内部所使用的对象和值本身是一个非常棒的特色，它使得 closure 本身变得非常好用。但是，捕获同时也引入了一些 bug 和引用循环的问题，甚至最后使得代码变得复杂和难以理解。&lt;/p&gt;

&lt;p&gt;当然，我并不是建议大家在所有的场景下去避免捕获发生，而是想通过这篇文章提供给大家一些捕获 self 的选择。在某些场景下，使用经典的 [weak self] 是最有效的解决方案，另外一些场景则可以使用某些手法来帮助你把自己的闭包代码写的更容易使用，也更容易理解吧。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>@autoclosure &amp;&amp; @escape</title>
      <link>https://hechen.xyz/post/autoclosure-escape/</link>
      <pubDate>Sun, 12 Nov 2017 20:01:54 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/autoclosure-escape/</guid>
      
        <description>

&lt;p&gt;我们知道在 &lt;code&gt;swift&lt;/code&gt; 中，闭包（closure）是一等公民，因此可以被当作参数传递，在学习 swift 的过程中经常会看到某些关键字修饰该闭包，&lt;code&gt;@autoclosure&lt;/code&gt;， &lt;code&gt;@escape&lt;/code&gt; 就是其中比较常见的两种关键字。&lt;/p&gt;

&lt;h3 id=&#34;escape-和-nonescape&#34;&gt;@escape 和 @nonescape&lt;/h3&gt;

&lt;p&gt;当一个闭包被当作参数传递给一个函数，但是当该函数内容执行完毕返回之后，该闭包才会被执行，我们就称该闭包要 escape 某个函数，那 &lt;code&gt;@escape&lt;/code&gt; 关键字就是用来表示该闭包是允许在函数返回之后被调用的。&lt;/p&gt;

&lt;p&gt;我们用 swift 官方文档的例子来看，如下所示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var completionHandlers: [() -&amp;gt; Void] = []

func someFunctionWithEscapingClosure(completionHandler: @escaping () -&amp;gt; Void) {
    completionHandlers.append(completionHandler)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;someFunctionWithEscapingClosure(_:)&lt;/code&gt; 的参数是一个闭包，函数内部会把传入的闭包存到之前声明的数组里以便之后进行调用，可以看到，在函数参数的声明部分添加了 &lt;code&gt;@escaping&lt;/code&gt; 关键字，如果这里不添加的话，就会在编译的时候报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: passing non-escaping parameter &#39;completionHandler&#39; to function expecting an @escaping closure
    completionHandlers.append(completionHandler)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对标记了 @escaping 关键字含义代表你必须在该闭包内部显式的使用 self 关键字，官方文档中又列举了另外一个例子，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func someFunctionWithNonescapingClosure(closure: () -&amp;gt; Void) {
    closure()
}
 
class SomeClass {
    var x = 10
    func doSomething() {
        someFunctionWithEscapingClosure { self.x = 100 }
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
 
let instance = SomeClass()
instance.doSomething()
print(instance.x)
// Prints &amp;quot;200&amp;quot;
 
completionHandlers.first?()
print(instance.x)
// Prints &amp;quot;100”
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;someFunctionWithEscapingClosure(_:)&lt;/code&gt; 是一个可逃逸的闭包，意味着你需要显示的调用 self 关键字， 而 &lt;code&gt;someFunctionWithNonescapingClosure(_:)&lt;/code&gt; 是非逃逸的闭包，意味着你可以隐式的调用 self。&lt;/p&gt;

&lt;h3 id=&#34;autoclosure&#34;&gt;@autoclosure&lt;/h3&gt;

&lt;h4 id=&#34;例子讲解&#34;&gt;例子讲解&lt;/h4&gt;

&lt;p&gt;通过一个🌰来说明 &lt;code&gt;@autoclosure&lt;/code&gt; 关键字到底起到什么作用。&lt;/p&gt;

&lt;p&gt;考虑下面这个函数 f，其需传入一个参数，类型是 &lt;code&gt;()-&amp;gt; Bool&lt;/code&gt; 的闭包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func f(predicate: () -&amp;gt; Bool) {
    if predicate() {
        print(&amp;quot;It&#39;s true&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过传入符合此类型的闭包进行调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(predicate: {2 &amp;gt; 1})
// &amp;quot;It&#39;s true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，如果我们忽略传入闭包的 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; ，编译就会错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f(predicate: 2 &amp;gt; 1)
// error: &#39;&amp;gt;&#39; produces &#39;Bool&#39;, not the expected contextual result type &#39;() -&amp;gt; Bool&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如文档中所说，一个 autoclosure (自主闭包？)是这样一种闭包: 当某个表达式被当做参数传递给一个函数的时候会被 wrap 成一个闭包，该闭包没有任何参数，其被调用的时候，返回的是其 wrap 的表达式的值。swift 提供这种语法糖就能够让你省略 {} 而直接写一个表达式。&lt;/p&gt;

&lt;p&gt;结合上面的例子来看，当你写个表达式类似 2 &amp;gt; 1 传给函数 f 的时候，该表达式会被自动包裹到一个闭包中，会自动处理为 { 2 &amp;gt; 1 } 而传递给函数 f。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func f(predicate: @autoclosure () -&amp;gt; Bool) {
    if predicate() {
        print(&amp;quot;It&#39;s true&amp;quot;)
    }
}

f(predicate: 2 &amp;gt; 1)
// It&#39;s true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⚠️ @autoclosure 并不支持带有输入参数的写法，也就是说只有形如 () -&amp;gt; T 的参数才能简化&lt;/p&gt;

&lt;h4 id=&#34;delay-evaluation&#34;&gt;Delay Evaluation&lt;/h4&gt;

&lt;p&gt;swift 提供了 ?? 操作符，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let nickName: String? = nil
let fullName: String = &amp;quot;John Appleseed&amp;quot;
let informalGreeting = &amp;quot;Hi \(nickName ?? fullName)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果某 Optional 存在就会返回其值，如果没有就会返回后面的默认值，当我们去看 ?? 的实现的时候能看到如下定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ??&amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () -&amp;gt; T?) -&amp;gt; T?

func ??&amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () -&amp;gt; T) -&amp;gt; T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看得出来 &lt;code&gt;??&lt;/code&gt; 是一个二元操作符，optional 指代 ?? 前面的输入，defaultValue 指代 &lt;code&gt;??&lt;/code&gt; 后面的参数，那我们就会想，我们上面的例子中 &lt;code&gt;fullName&lt;/code&gt; 只是一个 &lt;code&gt;String&lt;/code&gt;，怎么变成 &lt;code&gt;() -&amp;gt; T&lt;/code&gt; 类型的呢？ 这个就看前面的 &lt;code&gt;@autoclosure&lt;/code&gt; 的威力了，前面讲过了，该关键字把表达式的值封装成闭包并且返回该表达式的值了。 其实传入该方法的第二个参数是 &lt;code&gt;{ fullName }&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以可以想到该方法的实现应该如下所示，（当然 fullName 为 String 类型，应该会重载第二个函数实现）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ??&amp;lt;T&amp;gt;(optional: T?, defaultValue: @autoclosure () -&amp;gt; T) -&amp;gt; T {
    switch optional {
        case .Some(let value):
            return value
        case .None:
            return defaultValue()
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们还需要注意一点的是，使用 &lt;code&gt;@autoclosure&lt;/code&gt; 来修饰的表达式可以实现延迟计算，也就是说直到该闭包被调用之前，闭包里所被包裹的表达式都不会进行取值计算，也就避免了一定的开销，尤其是上面默认值是复杂计算得到的话。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>关于 iOS10 Notification 的那些事儿</title>
      <link>https://hechen.xyz/post/ios-notification/</link>
      <pubDate>Sat, 20 May 2017 10:10:54 +0000</pubDate>
      
      <guid>https://hechen.xyz/post/ios-notification/</guid>
      
        <description>

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;p&gt;推送通知我们大家都不陌生，可以说几乎每个使用智能手机的人每天都会被不同的通知 &lt;em&gt;打扰&lt;/em&gt; 到，正式因为合适的推送是吸引用户注意力的利器，其成为了各 App 吸引用户，将用户带回到 App 本身，提升用户的活跃度的一种必要的方式。当然要注意的是，推送本身是一件对用户影响特别大的事情，毕竟注意力被打断，因此合适的推送时机也是各个 App 开发者所要注意的，否则就会成为用户勿扰名单里的一员了。&lt;/p&gt;

&lt;p&gt;之前刚开始学习 iOS 开发的时候还整理了下当时部署 iOS 远程推送的流程，详见：&lt;a href=&#34;http://hechen.info/2015/07/30/iOS-Push-Notification/&#34;&gt;iOS 远端推送部署详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们大致回顾一下 iOS 平台关于推送都有哪些历程？&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&#34;历史&#34;&gt;历史&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;= iOS 6&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程推送通知 （iOS 3）&lt;/li&gt;
&lt;li&gt;本地通知 （iOS 4）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iOS 7  参考&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引入 Silent Remote Notifications&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iOS 8  参考 &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2014/713/&#34;&gt;WWDC 2014 Session 713&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引入 Actionable Notifications&lt;/li&gt;
&lt;li&gt;修改 Notification 的权限请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iOS 9  参考 &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2015/720/&#34;&gt;WWDC 2015 Session 720&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引入 Text Input Action&lt;/li&gt;
&lt;li&gt;UIUserNotificationActionBehavior&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iOS 10 参考 &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2016/707&#34;&gt;WWDC 707 Introduction to Notifications&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2016/708&#34;&gt;WWDC 708 Advanced Notifications&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UserNotification Framework&lt;/li&gt;
&lt;li&gt;Extensions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WWDC 2016 大会上，Apple 在 iOS 10 上引入了 &lt;strong&gt;UserNotification&lt;/strong&gt; 框架，可以说是对之前的各种代码做了一次重构。该框架统一了通知的行为，尤其是针对远程推送和本地推送不再有两套完全不同的使用方式了。&lt;/p&gt;

&lt;h3 id=&#34;变化&#34;&gt;变化&lt;/h3&gt;

&lt;p&gt;关于 iOS 10 上 UserNotification 框架的变化，主要从几个方面来讲述：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;权限申请&lt;/li&gt;
&lt;li&gt;推送内容变更&lt;/li&gt;
&lt;li&gt;推送管理&lt;/li&gt;
&lt;li&gt;Extensions&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;权限申请&#34;&gt;权限申请&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) {
    granted, error in
    if granted {
        // 用户允许进行通知
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;远程推送&#34;&gt;远程推送&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;// 向 APNs 请求 token：

// iOS 10 support
if #available(iOS 10, *) {  
    UNUserNotificationCenter.current().requestAuthorization(options:[.badge, .alert, .sound]){ (granted, error) in }
    application.registerForRemoteNotifications()
}
// iOS 9 support
else if #available(iOS 9, *) {  

UIApplication.shared.registerUserNotificationSettings(UIUserNotificationSettings(types: [.badge, .sound, .alert], categories: nil))
    UIApplication.shared.registerForRemoteNotifications()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于注册远程通知的回调方法一致，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;
// AppDelegate.swift
 func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
    let tokenString = deviceToken.hexString
    print(&amp;quot;Get Push token: \(tokenString)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;payloads&#34;&gt;Payloads&lt;/h4&gt;

&lt;p&gt;&amp;lt;  iOS 10&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt; {
   &amp;quot;aps&amp;quot;:{
     &amp;quot;alert&amp;quot;:&amp;quot;Test&amp;quot;,
     &amp;quot;sound&amp;quot;:&amp;quot;default&amp;quot;,
     &amp;quot;badge&amp;quot;:1
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iOS 10 系统提供了更为丰富的结构，比如可以指定 Title，Subtitle 等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
   &amp;quot;aps&amp;quot;:{
     &amp;quot;alert&amp;quot;:{
       &amp;quot;title&amp;quot;:&amp;quot;This is a title&amp;quot;,
       &amp;quot;subtitle&amp;quot;:&amp;quot;This is a subtitle&amp;quot;,
       &amp;quot;body&amp;quot;:&amp;quot;This is body&amp;quot;
     },
     &amp;quot;sound&amp;quot;:&amp;quot;default&amp;quot;,
     &amp;quot;badge&amp;quot;:1
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至，现在可以支持多媒体的展示了，在 payload 上也有相应的体现，例如下面几例：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;支持图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;aps&amp;quot;:{
        &amp;quot;alert&amp;quot;: {
            &amp;quot;title&amp;quot;: &amp;quot;Title: Notification Demo&amp;quot;, 
            &amp;quot;subtitle&amp;quot;: &amp;quot;Subtitle: show iOS 10 support!&amp;quot;,
            &amp;quot;body&amp;quot;: &amp;quot;The Main Body For Notification!&amp;quot;
            },
            &amp;quot;mutable-content&amp;quot;: 1
        },
    &amp;quot;image&amp;quot; : &amp;quot;https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持音频&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;    
{
    &amp;quot;aps&amp;quot;:{
        &amp;quot;alert&amp;quot;: {
        &amp;quot;title&amp;quot;: &amp;quot;Title: Notification Demo&amp;quot;, 
        &amp;quot;subtitle&amp;quot;: &amp;quot;Subtitle: show iOS 10 support!&amp;quot;, 
        &amp;quot;body&amp;quot;: &amp;quot;The Main Body For Notification!&amp;quot;
        },
        &amp;quot;mutable-content&amp;quot;: 1,
    },
    &amp;quot;audio&amp;quot; : &amp;quot;http://hao.1015600.com/upload/ring/000/982/d9924a7f4e4ab06e52a11dfdd32ffae1.mp3&amp;quot;,
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体所有的 Key 可以参考官方文档 &lt;a href=&#34;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/PayloadKeyReference.html&#34;&gt;Payload Key Reference&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意到有个 key:  launch-image ，可以指定用户点击通知启动 App 的时候的 Launch Image&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;可以撤销和更新通知了&#34;&gt;可以撤销和更新通知了！&lt;/h4&gt;

&lt;p&gt;UserNotification 框架 API 提供了通知的更新和撤销的接口。具体功能主要包含几个部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;删除未展示的通知&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
        let identifier = Constants.pendingRemoveNotificationIdentifier
        let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)
            
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print(&amp;quot;remove pending notification error: \(error)&amp;quot;)
            } else {
                print(&amp;quot;Notification request added: \(identifier)&amp;quot;)
            }
        }
            
        delay(2) {
            print(&amp;quot;Notification request removed: \(identifier)&amp;quot;)
            UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新未展示的通知&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
        let identifier = Constants.pendingUpdateNotificationIdentifier
        let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)
            
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print(&amp;quot;update pending notification error: \(error)&amp;quot;)
            } else {
                print(&amp;quot;Notification request added: \(identifier) with title1&amp;quot;)
            }
        }
            
        delay(2) {
            let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                
            // Add new request with the same identifier to update a notification.
            let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)
            UNUserNotificationCenter.current().add(newRequest) { error in
                if let error = error {
                    print(&amp;quot;update delivered notification error: \(error)&amp;quot;)
                } else {
                    print(&amp;quot;Notification request updated: \(identifier) with title2&amp;quot;)
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除已经展示的通知&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
        let identifier = Constants.pendingUpdateNotificationIdentifier
        let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)
            
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                print(&amp;quot;update pending notification error: \(error)&amp;quot;)
            } else {
                print(&amp;quot;Notification request added: \(identifier) with title1&amp;quot;)
            }
        }
            
        delay(2) {
            let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                
            // Add new request with the same identifier to update a notification.
            let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)
            UNUserNotificationCenter.current().add(newRequest) { error in
                if let error = error {
                    print(&amp;quot;update delivered notification error: \(error)&amp;quot;)
                } else {
                    print(&amp;quot;Notification request updated: \(identifier) with title2&amp;quot;)
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新已经展示的通知&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 3, repeats: false)
        let identifier = Constants.deliveredUpdateNotificationIdentifier
        let request = UNNotificationRequest(identifier: identifier, content: title1Content, trigger: trigger)
            
        UNUserNotificationCenter.current().add(request) { error in
            if let error = error {
                    
            } else {
                print(&amp;quot;Notification request added: \(identifier) with title1&amp;quot;)
            }
        }
            
        delay(4) {
            let newTrigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)
                
            // Add new request with the same identifier to update a notification.
            let newRequest = UNNotificationRequest(identifier: identifier, content: self.title2Content, trigger: newTrigger)
            UNUserNotificationCenter.current().add(newRequest) { error in
                if let error = error {
                        
                } else {
                    print(&amp;quot;Notification request updated: \(identifier) with title2&amp;quot;)
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，上述均是针对本地通知的操作，关于远程推送通知，目前只支持更新通知，远程推送可以进行通知的更新，在使用 Provider API 向 APNs 提交请求时，在 HTTP/2 的 header 中 apns-collapse-id key 的内容将被作为该推送的标识符进行使用。多次推送同一标识符的通知即可进行更新。&lt;/p&gt;

&lt;h4 id=&#34;notification-extension&#34;&gt;Notification Extension&lt;/h4&gt;

&lt;p&gt;iOS 10 中最重要的一个变化就是 Extension，从 iMessage Extension 到 SiriKit 中提供的  Intent Extension 等，那对于 UserNotification 来讲就是下面这两种 Extension：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/18D62919-DA73-4D3D-9B05-6071E6945764-1.png&#34; alt=&#34;18D62919-DA73-4D3D-9B05-6071E6945764&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Service Extension&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体而言，就是我们可以在收到通知之后，在展示给用户之前 ，也就是以Banner 或者 Alert 的形式 或者 进入通知中心之前，给我们一次截取并处理的机会，这样就给开发者提供了针对推送通知再加工的手段，并且远程推送多媒体也是通过 Service Extension 来实现的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使用在本机截取推送并替换内容的方式，可以完成端到端 (end-to-end) 的推送加密。你在服务器推送 payload 中加入加密过的文本，在客户端接到通知后使用预先定义或者获取过的密钥进行解密之后再显示。这样一来，即使推送信道被第三方截取，其中所传递的内容也还是安全的。使用这种方式来发送密码或者敏感信息，对于一些金融业务应用和聊天应用来说，应该是必备的特性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成 Extension 之后，系统已经为我们提供了模板，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;class NotificationService: UNNotificationServiceExtension {

    var contentHandler: ((UNNotificationContent) -&amp;gt; Void)?
    var bestAttemptContent: UNMutableNotificationContent?
    
    // 1
    override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&amp;gt; Void) {
        self.contentHandler = contentHandler
        bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent)
        
        if let bestAttemptContent = bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }
    
    // 2
    override func serviceExtensionTimeWillExpire() {
        // Called just before the extension will be terminated by the system.
        // Use this as an opportunity to deliver your &amp;quot;best attempt&amp;quot; at modified content, otherwise the original push payload will be used.
        if let contentHandler = contentHandler, let bestAttemptContent =  bestAttemptContent {
            contentHandler(bestAttemptContent)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Content Extension
iOS 10 SDK 新加的另一个 Content Extension 可以用来自定义通知的详细页面的视图。 下图中就是几款市面上目前已经实现过自定义 Content Extension 的 App 截图。需要注意的是：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个 PriceTag App 的通知样式，实际上是默认的系统显示行为。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/IMG_AD4882D0ECDE-1.jpeg&#34; alt=&#34;IMG_AD4882D0ECDE-1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中需要注意的一点是。如果不想默认显示通知内容，需要在 Content Extension 的 info.plist 文件中添加 UNNotificationExtensionDefaultContentHidden  并设置为 YES&lt;/p&gt;

&lt;h4 id=&#34;支持多媒体资源在通知中心的展示&#34;&gt;支持多媒体资源在通知中心的展示&lt;/h4&gt;

&lt;p&gt;iOS 10 中另一个比较显著的特点就是支持了多媒体的推送和展示。开发者现在可以在通知中嵌入图片、音频甚至视频，这极大丰富了推送内容的可读性和趣味性。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本地推送支持
本地通知添加多媒体比较简单一些，只需要通过本地磁盘上的文件 URL 创建一个 UNNotificationAttachment 对象，然后将这个对象放到数组中赋值给 content 的 attachments 属性就行了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let content = UNMutableNotificationContent()
content.title = &amp;quot;Image Notification&amp;quot;
content.body = &amp;quot;Show me an image!&amp;quot;

if let imageURL = Bundle.main.url(forResource: &amp;quot;image&amp;quot;, withExtension: &amp;quot;jpg&amp;quot;),
let attachment = try? UNNotificationAttachment(identifier: &amp;quot;imageAttachment&amp;quot;, url: imageURL, options: nil) {
content.attachments = [attachment]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;远程推送支持&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先需要在 payloads 结构中添加对富媒体的支持，aps 字典中添加字段&lt;code&gt;mutable-content&lt;/code&gt;并置为 1 来标识该远程通知是需要支持。 然后可以在 payloads 中添加资源地址，可以是本地的资源，也可以是需要 App 下载的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
  &amp;quot;aps&amp;quot;:{
    &amp;quot;alert&amp;quot;:{
      &amp;quot;title&amp;quot;:&amp;quot;Image Notification&amp;quot;,
      &amp;quot;body&amp;quot;:&amp;quot;Show me an image from web!&amp;quot;
    },
    &amp;quot;mutable-content&amp;quot;:1
  },
  &amp;quot;zh_image&amp;quot;: &amp;quot;https://pic1.zhimg.com/v2-0314056e4f13141b6ca2277078ec067c.jpg&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体支持多媒体文件的富媒体类型以及每一种类型所支持的大小详官方文档  &lt;a href=&#34;https://developer.apple.com/reference/usernotifications/unnotificationattachment&#34;&gt;UNNotificationAttachment&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一旦远程推送在 aps 中添加 mutable-content 的key 并设置为 1 之后，iOS 系统接收到该推送之后就会唤起我们配套的 Service Extension 来做进一步处理，我们可以在其中下载对应 zh_image 链接的图片，然后生成 Attachment 再丢给系统处理即可。 详细做法就是在上一节讲 Service Extension 中的 &lt;code&gt;didReceive&lt;/code&gt; 中写相应逻辑即可，具体代码如下所示：&lt;/p&gt;

&lt;p&gt;当然，这里的处理时间是存在时间限制的，如果处理超时系统就会回收该 Extension，并且调用 &lt;code&gt;serviceExtensionTimeWillExpire&lt;/code&gt; 方法，因此每个人收到带有附件的推送之后不一定展示相同，例如下图所示的情况，第一张和第二张就属于正常设置了附件的情况，而第三张就是没有在有限时间内正确设置附件的情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/14953507334611.png&#34; alt=&#34;未成功设置附件的情况&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;推送证书的配置&#34;&gt;推送证书的配置&lt;/h4&gt;

&lt;p&gt;下图是获取推送通知证书并将其注册到 Leancloud 的流程，最关键的地方其实就是需要在本机生成 CSR 文件提交到 Apple Developer Website 生成 Push Certification 文件。&lt;/p&gt;

&lt;p&gt;主要有几个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;AppID 关于 Remote Push 的 注册&lt;/li&gt;
&lt;li&gt;生成推送证书&lt;/li&gt;
&lt;li&gt;转换证书为 P12 文件，并提供给 Leancloud&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/02.png&#34; alt=&#34;02&#34; /&gt;&lt;/p&gt;

&lt;p&gt;XCode 8 的 Auto Signing 已经省去了难以名状的复杂，但是还是有一点小事情我们需要做。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22.png&#34; alt=&#34;iOS App IDs - Apple Developer Google Chrome, 今天 at 下午5.01.22&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/0CB09A98-0D9B-4E76-BA7C-9A1766CFEC42.png&#34; alt=&#34;0CB09A98-0D9B-4E76-BA7C-9A1766CFE&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47.png&#34; alt=&#34;Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.07.47&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们需要生成 CSR 文件 ，按照指定步骤按部就班来就行，最后会生成 默认文件 &lt;em&gt;CertificateSigningRequest.certSigningRequest&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/Finder Finder, 今天 at 下午4.59.55.png&#34; alt=&#34;Finder Finder, 今天 at 下午4.59.55&#34; /&gt;
&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/证书助理 证书助理, 今天 at 下午5.05.42.png&#34; alt=&#34;证书助理 证书助理, 今天 at 下午5.05.42&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着之前的步骤，选择 CSR 文件上传。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07.png&#34; alt=&#34;Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.07&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上传成功之后就会生成 Push 证书，下载到本机安装上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://7xilk1.com1.z0.glb.clouddn.com/Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58.png&#34; alt=&#34;Add - iOS Certificates - Apple Developer Google Chrome, 今天 at 下午5.09.58&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;demo-演示-knuff-https-github-com-knuffapp-knuff&#34;&gt;Demo 演示  &lt;a href=&#34;https://github.com/KnuffApp/Knuff&#34;&gt;Knuff&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194-CH3-SW1&#34;&gt;Local and Remote Notification Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.apple.com/reference/usernotifications&#34;&gt;UserNotifications 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wereadteam.github.io/2017/03/13/Signature/&#34;&gt;iOS App 签名的原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@scomper/探究-iphone-的后台刷新-a7a96cb426d4&#34;&gt;iPhone 的后台刷新&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
  </channel>
</rss>